{"file_contents":{"app/api/routes.py":{"content":"from fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nfrom datetime import datetime\nfrom typing import List, Optional, Dict, Any\nimport json\n\nfrom app.database.models import get_session, Session\nfrom app.database.crud import (\n    UserCRUD, MedicationCRUD, ConversationCRUD, ReminderCRUD,\n    MedicationLogCRUD, CaregiverAlertCRUD\n)\nfrom app.agents.companion_agent import CompanionAgent\nfrom app.memory.conversation_store import ConversationMemoryStore\n\napp = FastAPI(title=\"Carely API\", description=\"AI Companion for Elderly Care\", version=\"1.0.0\")\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Initialize companion agent\ncompanion_agent = CompanionAgent()\n\n# Pydantic models for API requests\nclass ChatMessage(BaseModel):\n    user_id: int\n    message: str\n    conversation_type: str = \"general\"\n\nclass MedicationCreate(BaseModel):\n    user_id: int\n    name: str\n    dosage: str\n    frequency: str\n    schedule_times: List[str]\n    instructions: Optional[str] = None\n\nclass MedicationLog(BaseModel):\n    user_id: int\n    medication_id: int\n    status: str = \"taken\"\n    notes: Optional[str] = None\n\nclass UserCreate(BaseModel):\n    name: str\n    email: Optional[str] = None\n    phone: Optional[str] = None\n    preferences: Optional[Dict[str, Any]] = None\n    emergency_contact: Optional[str] = None\n\nclass CustomReminder(BaseModel):\n    user_id: int\n    title: str\n    message: str\n    scheduled_time: datetime\n\n# Dependency to get database session\ndef get_db_session():\n    return get_session()\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint\"\"\"\n    return {\"message\": \"Carely API - AI Companion for Elderly Care\"}\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\", \"timestamp\": datetime.now()}\n\n# User endpoints\n@app.post(\"/users/\")\nasync def create_user(user: UserCreate):\n    \"\"\"Create a new user\"\"\"\n    try:\n        new_user = UserCRUD.create_user(\n            name=user.name,\n            email=user.email,\n            phone=user.phone,\n            preferences=user.preferences,\n            emergency_contact=user.emergency_contact\n        )\n        return {\"message\": \"User created successfully\", \"user_id\": new_user.id}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/users/\")\nasync def get_all_users():\n    \"\"\"Get all users\"\"\"\n    try:\n        users = UserCRUD.get_all_users()\n        return {\"users\": [{\"id\": u.id, \"name\": u.name, \"email\": u.email} for u in users]}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    \"\"\"Get user by ID\"\"\"\n    try:\n        user = UserCRUD.get_user(user_id)\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        return user\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Chat endpoints\n@app.post(\"/chat/\")\nasync def chat_with_companion(message: ChatMessage):\n    \"\"\"Chat with the AI companion\"\"\"\n    try:\n        response = companion_agent.generate_response(\n            user_id=message.user_id,\n            user_message=message.message,\n            conversation_type=message.conversation_type\n        )\n        return response\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/chat/history/{user_id}\")\nasync def get_chat_history(user_id: int, limit: int = 50):\n    \"\"\"Get chat history for a user\"\"\"\n    try:\n        conversations = ConversationCRUD.get_user_conversations(user_id, limit)\n        return {\n            \"conversations\": [\n                {\n                    \"id\": c.id,\n                    \"message\": c.message,\n                    \"response\": c.response,\n                    \"sentiment_score\": c.sentiment_score,\n                    \"sentiment_label\": c.sentiment_label,\n                    \"timestamp\": c.timestamp,\n                    \"conversation_type\": c.conversation_type\n                }\n                for c in conversations\n            ]\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Medication endpoints\n@app.post(\"/medications/\")\nasync def create_medication(medication: MedicationCreate):\n    \"\"\"Create a new medication\"\"\"\n    try:\n        new_med = MedicationCRUD.create_medication(\n            user_id=medication.user_id,\n            name=medication.name,\n            dosage=medication.dosage,\n            frequency=medication.frequency,\n            schedule_times=medication.schedule_times,\n            instructions=medication.instructions\n        )\n        return {\"message\": \"Medication created successfully\", \"medication_id\": new_med.id}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/medications/{user_id}\")\nasync def get_user_medications(user_id: int):\n    \"\"\"Get all medications for a user\"\"\"\n    try:\n        medications = MedicationCRUD.get_user_medications(user_id)\n        return {\n            \"medications\": [\n                {\n                    \"id\": m.id,\n                    \"name\": m.name,\n                    \"dosage\": m.dosage,\n                    \"frequency\": m.frequency,\n                    \"schedule_times\": json.loads(m.schedule_times) if m.schedule_times else [],\n                    \"instructions\": m.instructions,\n                    \"active\": m.active\n                }\n                for m in medications\n            ]\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/medications/log/\")\nasync def log_medication_taken(log: MedicationLog):\n    \"\"\"Log medication intake\"\"\"\n    try:\n        medication_log = MedicationLogCRUD.log_medication_taken(\n            user_id=log.user_id,\n            medication_id=log.medication_id,\n            scheduled_time=datetime.now(),\n            status=log.status,\n            notes=log.notes\n        )\n        return {\"message\": \"Medication logged successfully\", \"log_id\": medication_log.id}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/medications/adherence/{user_id}\")\nasync def get_medication_adherence(user_id: int, days: int = 7):\n    \"\"\"Get medication adherence statistics\"\"\"\n    try:\n        adherence = MedicationLogCRUD.get_medication_adherence(user_id, days)\n        return adherence\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Reminder endpoints\n@app.get(\"/reminders/{user_id}\")\nasync def get_pending_reminders(user_id: int):\n    \"\"\"Get pending reminders for a user\"\"\"\n    try:\n        reminders = ReminderCRUD.get_pending_reminders(user_id)\n        return {\n            \"reminders\": [\n                {\n                    \"id\": r.id,\n                    \"type\": r.reminder_type,\n                    \"title\": r.title,\n                    \"message\": r.message,\n                    \"scheduled_time\": r.scheduled_time,\n                    \"medication_id\": r.medication_id\n                }\n                for r in reminders\n            ]\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/reminders/{reminder_id}/complete\")\nasync def complete_reminder(reminder_id: int):\n    \"\"\"Mark reminder as completed\"\"\"\n    try:\n        reminder = ReminderCRUD.complete_reminder(reminder_id)\n        if not reminder:\n            raise HTTPException(status_code=404, detail=\"Reminder not found\")\n        return {\"message\": \"Reminder completed successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Alert endpoints\n@app.get(\"/alerts/{user_id}\")\nasync def get_caregiver_alerts(user_id: int):\n    \"\"\"Get caregiver alerts for a user\"\"\"\n    try:\n        alerts = CaregiverAlertCRUD.get_unresolved_alerts(user_id)\n        return {\n            \"alerts\": [\n                {\n                    \"id\": a.id,\n                    \"type\": a.alert_type,\n                    \"severity\": a.severity,\n                    \"title\": a.title,\n                    \"description\": a.description,\n                    \"created_at\": a.created_at,\n                    \"resolved\": a.resolved\n                }\n                for a in alerts\n            ]\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/alerts/{alert_id}/resolve\")\nasync def resolve_alert(alert_id: int):\n    \"\"\"Resolve a caregiver alert\"\"\"\n    try:\n        alert = CaregiverAlertCRUD.resolve_alert(alert_id)\n        if not alert:\n            raise HTTPException(status_code=404, detail=\"Alert not found\")\n        return {\"message\": \"Alert resolved successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Memory and context endpoints\n@app.get(\"/memory/{user_id}/summary\")\nasync def get_conversation_summary(user_id: int, days: int = 7):\n    \"\"\"Get conversation summary for a user\"\"\"\n    try:\n        memory_store = ConversationMemoryStore(user_id)\n        summary = memory_store.get_conversation_summary(days)\n        return {\"summary\": summary}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/memory/{user_id}/context\")\nasync def get_important_context(user_id: int):\n    \"\"\"Get important contextual information about a user\"\"\"\n    try:\n        memory_store = ConversationMemoryStore(user_id)\n        context = memory_store.get_important_context()\n        return {\"context\": context}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n# Analytics endpoints\n@app.get(\"/analytics/{user_id}/sentiment\")\nasync def get_sentiment_trends(user_id: int, days: int = 30):\n    \"\"\"Get sentiment trends for a user\"\"\"\n    try:\n        conversations = ConversationCRUD.get_recent_sentiment_data(user_id, days)\n        sentiment_data = [\n            {\n                \"date\": c.timestamp.date().isoformat(),\n                \"sentiment_score\": c.sentiment_score,\n                \"sentiment_label\": c.sentiment_label\n            }\n            for c in conversations\n            if c.sentiment_score is not None\n        ]\n        return {\"sentiment_trends\": sentiment_data}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n","size_bytes":10654},"app/agents/companion_agent.py":{"content":"import os\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\nfrom openai import OpenAI\nfrom app.database.crud import (ConversationCRUD, MedicationCRUD,\n                               MedicationLogCRUD, CaregiverAlertCRUD, UserCRUD,\n                               PersonalEventCRUD)\nfrom utils.sentiment_analysis import analyze_sentiment\nfrom utils.emergency_detection import detect_emergency\n\n\n# the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\nclass CompanionAgent:\n\n    def __init__(self):\n        self.client = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n        self.model = \"gpt-5\"  # Using latest model\n\n        # System prompt for elderly care companion\n        self.system_prompt = \"\"\"You are Carely, a warm, empathetic AI companion designed specifically for elderly care. Your role is to:\n\n1. PERSONALITY: Be gentle, patient, understanding, and warm. Use a conversational tone that feels like talking to a caring friend or family member.\n\n2. COMMUNICATION STYLE:\n   - Keep responses clear and not too long\n   - Avoid medical jargon - use simple, everyday language\n   - Show genuine interest in their wellbeing\n   - Remember and reference past conversations when appropriate\n   - Be encouraging and supportive\n\n3. CORE RESPONSIBILITIES:\n   - Help with medication reminders and tracking\n   - Conduct daily wellness check-ins\n   - Provide emotional support and companionship\n   - Alert caregivers when concerning patterns emerge\n   - Remember personal details and preferences\n\n4. SAFETY: If you detect signs of medical emergency, severe depression, or immediate danger, recommend contacting emergency services or their caregiver immediately.\n\n5. TOOLS AVAILABLE:\n   - log_medication: Record when medications are taken\n   - check_schedule: View upcoming medications and reminders\n   - alert_caregiver: Send alerts to designated caregivers for concerning patterns\n\nAlways respond with empathy and care, as if you're genuinely concerned about their wellbeing.\"\"\"\n\n    def get_conversation_context(self, user_id: int, limit: int = 5) -> str:\n        \"\"\"Get recent conversation context for memory\"\"\"\n        conversations = ConversationCRUD.get_user_conversations(user_id, limit)\n        if not conversations:\n            return \"No previous conversations.\"\n\n        context = \"Recent conversation history:\\n\"\n        for conv in reversed(conversations):  # Show chronologically\n            context += f\"User: {conv.message}\\nCarely: {conv.response}\\n---\\n\"\n        return context\n\n    def get_personal_events_context(self, user_id: int) -> str:\n        \"\"\"Get upcoming personal events for personalized conversation\"\"\"\n        upcoming_events = PersonalEventCRUD.get_upcoming_events(user_id,\n                                                                days=30)\n\n        if not upcoming_events:\n            return \"No upcoming events stored.\"\n\n        context = \"Upcoming important events to remember:\\n\"\n        for event in upcoming_events:\n            days_until = (event.event_date - datetime.now()).days\n            context += f\"- {event.title} ({event.event_type}) in {days_until} days\"\n            if event.description:\n                context += f\": {event.description}\"\n            context += \"\\n\"\n\n        return context\n\n    def log_medication_tool(self,\n                            user_id: int,\n                            medication_name: str,\n                            notes: str = \"\") -> str:\n        \"\"\"Tool to log medication intake\"\"\"\n        try:\n            medications = MedicationCRUD.get_user_medications(user_id)\n            medication = next((med for med in medications\n                               if medication_name.lower() in med.name.lower()),\n                              None)\n\n            if not medication:\n                return f\"I couldn't find a medication named '{medication_name}' in your schedule. Please check the spelling or ask your caregiver to add it.\"\n\n            # Log the medication as taken\n            MedicationLogCRUD.log_medication_taken(\n                user_id=user_id,\n                medication_id=medication.id,\n                scheduled_time=datetime.now(),\n                status=\"taken\",\n                notes=notes)\n\n            return f\"Great! I've recorded that you took your {medication.name} ({medication.dosage}) at {datetime.now().strftime('%I:%M %p')}.\"\n\n        except Exception as e:\n            return f\"I had trouble logging your medication. Please try again or contact your caregiver.\"\n\n    def check_schedule_tool(self, user_id: int) -> str:\n        \"\"\"Tool to check upcoming medications and reminders\"\"\"\n        try:\n            medications = MedicationCRUD.get_user_medications(user_id)\n            if not medications:\n                return \"You don't have any medications scheduled right now.\"\n\n            schedule_info = \"Here's your medication schedule:\\n\\n\"\n            for med in medications:\n                times = json.loads(\n                    med.schedule_times) if med.schedule_times else []\n                schedule_info += f\"‚Ä¢ {med.name} ({med.dosage}) - {med.frequency}\\n\"\n                if times:\n                    schedule_info += f\"  Times: {', '.join(times)}\\n\"\n                schedule_info += \"\\n\"\n\n            return schedule_info\n\n        except Exception as e:\n            return \"I had trouble checking your schedule. Please try again later.\"\n\n    def alert_caregiver_tool(self,\n                             user_id: int,\n                             alert_type: str,\n                             description: str,\n                             severity: str = \"medium\") -> str:\n        \"\"\"Tool to alert caregivers about concerning patterns\"\"\"\n        try:\n            user = UserCRUD.get_user(user_id)\n            title = f\"Alert for {user.name if user else 'Patient'}\"\n\n            CaregiverAlertCRUD.create_alert(user_id=user_id,\n                                            alert_type=alert_type,\n                                            title=title,\n                                            description=description,\n                                            severity=severity)\n\n            return \"I've notified your caregiver about this. They'll be in touch soon to check on you.\"\n\n        except Exception as e:\n            return \"I had trouble sending the alert. Please contact your caregiver directly if this is urgent.\"\n\n    def should_alert_caregiver(self, user_id: int, sentiment_score: float,\n                               message: str) -> bool:\n        \"\"\"Determine if caregiver should be alerted based on conversation\"\"\"\n        # Alert for very negative sentiment\n        if sentiment_score < -0.7:\n            return True\n\n        # Check for concerning keywords\n        concerning_keywords = [\n            \"pain\", \"hurt\", \"dizzy\", \"fall\", \"fell\", \"emergency\", \"help\",\n            \"can't breathe\", \"chest pain\", \"confused\", \"lost\", \"scared\"\n        ]\n\n        message_lower = message.lower()\n        return any(keyword in message_lower for keyword in concerning_keywords)\n\n    def generate_response(\n            self,\n            user_id: int,\n            user_message: str,\n            conversation_type: str = \"general\") -> Dict[str, Any]:\n        \"\"\"Generate AI response with context and tools\"\"\"\n        try:\n            # Get conversation context\n            context = self.get_conversation_context(user_id)\n\n            # Get personal events context\n            events_context = self.get_personal_events_context(user_id)\n\n            # Get user info\n            user = UserCRUD.get_user(user_id)\n            user_name = user.name if user else \"there\"\n\n            # Analyze sentiment of user message\n            sentiment_result = analyze_sentiment(user_message)\n            sentiment_score = sentiment_result.get(\"score\", 0)\n            sentiment_label = sentiment_result.get(\"label\", \"neutral\")\n            \n            # Detect emergency situations\n            emergency_result = detect_emergency(user_message)\n            is_emergency = emergency_result.get(\"is_emergency\", False)\n            emergency_severity = emergency_result.get(\"severity\", \"low\")\n            emergency_concerns = emergency_result.get(\"concerns\", [])\n\n            # Build the prompt\n            prompt = f\"\"\"Context: {context}\n\n{events_context}\n\nUser's name: {user_name}\nConversation type: {conversation_type}\nCurrent message: {user_message}\n\nPlease respond as Carely, keeping in mind:\n- This person's conversation history\n- Their upcoming events and important dates\n- The type of conversation (general chat, check-in, etc.)\n- Be warm, caring, and supportive\n- If they mention medications, offer to help log them\n- If they seem distressed, offer appropriate support\n- Reference their upcoming events naturally when relevant (e.g., \"How are you feeling about your grandson's birthday coming up?\")\n\nRespond naturally and warmly.\"\"\"\n\n            # Generate response\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[{\n                    \"role\": \"system\",\n                    \"content\": self.system_prompt\n                }, {\n                    \"role\": \"user\",\n                    \"content\": prompt\n                }],\n                max_completion_tokens=512)\n\n            ai_response = response.choices[0].message.content\n\n            # Save conversation\n            conversation = ConversationCRUD.save_conversation(\n                user_id=user_id,\n                message=user_message,\n                response=ai_response,\n                sentiment_score=sentiment_score,\n                sentiment_label=sentiment_label,\n                conversation_type=conversation_type)\n\n            # Check if caregiver alert is needed\n            alert_sent = False\n            if self.should_alert_caregiver(user_id, sentiment_score,\n                                           user_message):\n                self.alert_caregiver_tool(\n                    user_id=user_id,\n                    alert_type=\"mood_concern\",\n                    description=\n                    f\"User expressed concerning sentiment: '{user_message}' (sentiment: {sentiment_label})\",\n                    severity=\"medium\" if sentiment_score > -0.8 else \"high\")\n                alert_sent = True\n\n            return {\n                \"response\": ai_response,\n                \"sentiment_score\": sentiment_score,\n                \"sentiment_label\": sentiment_label,\n                \"alert_sent\": alert_sent,\n                \"conversation_id\": conversation.id,\n                \"is_emergency\": is_emergency,\n                \"emergency_severity\": emergency_severity,\n                \"emergency_concerns\": emergency_concerns\n            }\n\n        except Exception as e:\n            # Fallback response\n            error_response = f\"I'm sorry, I'm having a bit of trouble right now. But I'm here for you! Is there anything specific you'd like to talk about or any way I can help you today?\"\n\n            # Still save the conversation attempt\n            ConversationCRUD.save_conversation(\n                user_id=user_id,\n                message=user_message,\n                response=error_response,\n                conversation_type=conversation_type)\n\n            return {\n                \"response\": error_response,\n                \"sentiment_score\": 0,\n                \"sentiment_label\": \"neutral\",\n                \"alert_sent\": False,\n                \"error\": str(e)\n            }\n\n    def conduct_daily_checkin(self,\n                              user_id: int,\n                              checkin_type: str = \"morning\") -> Dict[str, Any]:\n        \"\"\"Conduct a daily check-in with the user\"\"\"\n        user = UserCRUD.get_user(user_id)\n        user_name = user.name if user else \"there\"\n\n        checkin_prompts = {\n            \"morning\":\n            f\"Good morning, {user_name}! I hope you slept well. How are you feeling this morning? Did you take your morning medications?\",\n            \"afternoon\":\n            f\"Good afternoon, {user_name}! How has your day been so far? Are you feeling alright?\",\n            \"evening\":\n            f\"Good evening, {user_name}! How was your day? Did you remember to take all your medications today?\"\n        }\n\n        prompt = checkin_prompts.get(checkin_type, checkin_prompts[\"morning\"])\n\n        # For check-ins, we don't wait for user response - we just send the prompt\n        # The user can respond through the normal chat interface\n        return {\n            \"prompt\": prompt,\n            \"checkin_type\": checkin_type,\n            \"scheduled_time\": datetime.now()\n        }\n","size_bytes":12712},"frontend/dashboard.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta, time\nimport json\nfrom typing import List, Dict, Any\nfrom streamlit_mic_recorder import speech_to_text\n\nfrom app.database.crud import (\n    UserCRUD, MedicationCRUD, ConversationCRUD, ReminderCRUD,\n    MedicationLogCRUD, CaregiverAlertCRUD\n)\nfrom app.agents.companion_agent import CompanionAgent\nfrom utils.sentiment_analysis import analyze_sentiment, get_sentiment_emoji, get_sentiment_color\n\ndef run_dashboard():\n    \"\"\"Main dashboard function\"\"\"\n    st.title(\"üè• Carely - AI Companion Dashboard\")\n    st.markdown(\"*Your caring AI companion for elderly care*\")\n    \n    # Initialize session state\n    if 'companion_agent' not in st.session_state:\n        st.session_state.companion_agent = CompanionAgent()\n    \n    # Sidebar for user selection\n    with st.sidebar:\n        st.header(\"üë§ Select User\")\n        users = UserCRUD.get_all_users()\n        \n        if not users:\n            st.error(\"No users found. Please add users first.\")\n            show_user_management()\n            return\n        \n        user_options = {f\"{user.name} (ID: {user.id})\": user.id for user in users}\n        selected_user_key = st.selectbox(\"Choose a user:\", list(user_options.keys()))\n        selected_user_id = user_options[selected_user_key]\n        \n        st.divider()\n        \n        # Navigation\n        st.header(\"üì± Navigation\")\n        page = st.radio(\n            \"Choose a section:\",\n            [\n                \"üè† Overview\",\n                \"üí¨ Chat with Carely\",\n                \"üíä Medications\",\n                \"üìä Health Insights\",\n                \"üö® Alerts & Reminders\",\n                \"üë• User Management\"\n            ]\n        )\n    \n    # Main content based on selected page\n    if page == \"üè† Overview\":\n        show_overview(selected_user_id)\n    elif page == \"üí¨ Chat with Carely\":\n        show_chat_interface(selected_user_id)\n    elif page == \"üíä Medications\":\n        show_medication_management(selected_user_id)\n    elif page == \"üìä Health Insights\":\n        show_health_insights(selected_user_id)\n    elif page == \"üö® Alerts & Reminders\":\n        show_alerts_and_reminders(selected_user_id)\n    elif page == \"üë• User Management\":\n        show_user_management()\n\ndef show_overview(user_id: int):\n    \"\"\"Show overview dashboard\"\"\"\n    user = UserCRUD.get_user(user_id)\n    if not user:\n        st.error(\"User not found\")\n        return\n    \n    st.header(f\"Overview for {user.name}\")\n    \n    # Today's summary cards\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"üë§ User\", user.name)\n    \n    with col2:\n        # Medication adherence today\n        adherence = MedicationLogCRUD.get_medication_adherence(user_id, days=1)\n        adherence_rate = adherence.get(\"adherence_rate\", 0)\n        st.metric(\n            \"üíä Today's Adherence\", \n            f\"{adherence_rate:.0f}%\",\n            delta=f\"{adherence.get('taken', 0)}/{adherence.get('total', 0)} doses\"\n        )\n    \n    with col3:\n        # Recent mood\n        conversations = ConversationCRUD.get_recent_sentiment_data(user_id, days=1)\n        if conversations:\n            avg_mood = sum(c.sentiment_score for c in conversations if c.sentiment_score) / len([c for c in conversations if c.sentiment_score])\n            mood_emoji = get_sentiment_emoji(avg_mood)\n            st.metric(\"üòä Today's Mood\", f\"{mood_emoji} {avg_mood:.2f}\")\n        else:\n            st.metric(\"üòä Today's Mood\", \"No data\")\n    \n    with col4:\n        # Unresolved alerts\n        alerts = CaregiverAlertCRUD.get_unresolved_alerts(user_id)\n        alert_count = len(alerts)\n        st.metric(\"üö® Active Alerts\", alert_count)\n    \n    st.divider()\n    \n    # Today's schedule and recent activity\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"üìÖ Today's Schedule\")\n        \n        # Get pending reminders\n        reminders = ReminderCRUD.get_pending_reminders(user_id)\n        today_reminders = [\n            r for r in reminders \n            if r.scheduled_time.date() == datetime.now().date()\n        ]\n        \n        if today_reminders:\n            for reminder in today_reminders[:5]:\n                with st.container():\n                    st.write(f\"**{reminder.scheduled_time.strftime('%I:%M %p')}** - {reminder.title}\")\n                    st.write(f\"_{reminder.message}_\")\n                    st.divider()\n        else:\n            st.info(\"No pending reminders for today\")\n    \n    with col2:\n        st.subheader(\"üí¨ Recent Conversations\")\n        \n        recent_conversations = ConversationCRUD.get_user_conversations(user_id, limit=3)\n        \n        if recent_conversations:\n            for conv in recent_conversations:\n                with st.container():\n                    # Show sentiment with color\n                    sentiment_color = get_sentiment_color(conv.sentiment_score or 0)\n                    sentiment_emoji = get_sentiment_emoji(conv.sentiment_score or 0)\n                    \n                    st.write(f\"**{conv.timestamp.strftime('%I:%M %p')}** {sentiment_emoji}\")\n                    st.write(f\"You: {conv.message}\")\n                    st.write(f\"Carely: {conv.response}\")\n                    st.divider()\n        else:\n            st.info(\"No recent conversations\")\n    \n    # Quick actions\n    st.subheader(\"‚ö° Quick Actions\")\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        if st.button(\"üíä Log Medication Taken\", use_container_width=True):\n            st.session_state.show_medication_log = True\n    \n    with col2:\n        if st.button(\"üí¨ Chat with Carely\", use_container_width=True):\n            st.session_state.current_page = \"chat\"\n    \n    with col3:\n        if st.button(\"üìä View Health Report\", use_container_width=True):\n            st.session_state.current_page = \"health\"\n    \n    # Quick medication logging\n    if st.session_state.get('show_medication_log', False):\n        st.subheader(\"üíä Quick Medication Log\")\n        \n        medications = MedicationCRUD.get_user_medications(user_id)\n        if medications:\n            med_options = {f\"{med.name} ({med.dosage})\": med.id for med in medications}\n            selected_med = st.selectbox(\"Select medication:\", list(med_options.keys()))\n            notes = st.text_area(\"Notes (optional):\")\n            \n            if st.button(\"Log as Taken\"):\n                MedicationLogCRUD.log_medication_taken(\n                    user_id=user_id,\n                    medication_id=med_options[selected_med],\n                    scheduled_time=datetime.now(),\n                    status=\"taken\",\n                    notes=notes or None\n                )\n                st.success(\"Medication logged successfully!\")\n                st.session_state.show_medication_log = False\n                st.rerun()\n\ndef show_chat_interface(user_id: int):\n    \"\"\"Show chat interface with Carely\"\"\"\n    user = UserCRUD.get_user(user_id)\n    st.header(f\"üí¨ Chat with Carely - {user.name}\")\n    \n    # Initialize chat history in session state\n    if 'chat_history' not in st.session_state:\n        st.session_state.chat_history = []\n    \n    # Load recent conversations\n    if not st.session_state.chat_history:\n        recent_convs = ConversationCRUD.get_user_conversations(user_id, limit=10)\n        st.session_state.chat_history = [\n            {\"role\": \"user\", \"content\": conv.message, \"timestamp\": conv.timestamp}\n            for conv in reversed(recent_convs)\n        ] + [\n            {\"role\": \"assistant\", \"content\": conv.response, \"timestamp\": conv.timestamp}\n            for conv in reversed(recent_convs)\n        ]\n    \n    # Voice input section\n    st.markdown(\"### üé§ Voice Input\")\n    col1, col2 = st.columns([3, 1])\n    \n    with col1:\n        voice_text = speech_to_text(\n            language='en',\n            start_prompt=\"üé§ Press to speak\",\n            stop_prompt=\"‚èπÔ∏è Recording...\",\n            just_once=False,\n            use_container_width=True,\n            key=f'voice_input_{user_id}'\n        )\n    \n    with col2:\n        st.info(\"üí° Click the mic button and speak your message!\")\n    \n    # Process voice input\n    if voice_text:\n        # Automatically process voice input\n        prompt = voice_text\n        \n        # Add user message to chat\n        with st.chat_message(\"user\"):\n            st.write(f\"üé§ {prompt}\")\n        \n        # Generate AI response\n        with st.chat_message(\"assistant\", avatar=\"üè•\"):\n            with st.spinner(\"Carely is thinking...\"):\n                response_data = st.session_state.companion_agent.generate_response(\n                    user_id=user_id,\n                    user_message=prompt\n                )\n            \n            st.write(response_data[\"response\"])\n            \n            # Show sentiment if available\n            if response_data.get(\"sentiment_score\") is not None:\n                sentiment_emoji = get_sentiment_emoji(response_data[\"sentiment_score\"])\n                st.caption(f\"Detected mood: {sentiment_emoji} {response_data['sentiment_label']}\")\n        \n        # Update session state\n        st.session_state.chat_history.append({\"role\": \"user\", \"content\": f\"üé§ {prompt}\", \"timestamp\": datetime.now()})\n        st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response_data[\"response\"], \"timestamp\": datetime.now()})\n        \n        # Rerun to show the new messages\n        st.rerun()\n    \n    st.divider()\n    \n    # Chat container\n    chat_container = st.container()\n    \n    with chat_container:\n        # Display chat history\n        for message in st.session_state.chat_history[-10:]:  # Show last 10 messages\n            if message[\"role\"] == \"user\":\n                with st.chat_message(\"user\"):\n                    st.write(message[\"content\"])\n            else:\n                with st.chat_message(\"assistant\", avatar=\"üè•\"):\n                    st.write(message[\"content\"])\n    \n    # Chat input\n    if prompt := st.chat_input(f\"Type your message to Carely here, {user.name}...\"):\n        # Add user message to chat\n        with st.chat_message(\"user\"):\n            st.write(prompt)\n        \n        # Generate AI response\n        with st.chat_message(\"assistant\", avatar=\"üè•\"):\n            with st.spinner(\"Carely is thinking...\"):\n                response_data = st.session_state.companion_agent.generate_response(\n                    user_id=user_id,\n                    user_message=prompt\n                )\n            \n            st.write(response_data[\"response\"])\n            \n            # Show sentiment if available\n            if response_data.get(\"sentiment_score\") is not None:\n                sentiment_emoji = get_sentiment_emoji(response_data[\"sentiment_score\"])\n                st.caption(f\"Detected mood: {sentiment_emoji} {response_data['sentiment_label']}\")\n        \n        # Update session state\n        st.session_state.chat_history.append({\"role\": \"user\", \"content\": prompt, \"timestamp\": datetime.now()})\n        st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response_data[\"response\"], \"timestamp\": datetime.now()})\n        \n        # Rerun to show the new messages\n        st.rerun()\n    \n    # Chat actions\n    st.divider()\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        if st.button(\"üóëÔ∏è Clear Chat\"):\n            st.session_state.chat_history = []\n            st.rerun()\n    \n    with col2:\n        if st.button(\"üìä View Mood Trends\"):\n            st.session_state.show_mood_analysis = True\n    \n    with col3:\n        if st.button(\"üíä Quick Med Check\"):\n            # Quick medication check\n            medications = MedicationCRUD.get_user_medications(user_id)\n            if medications:\n                med_list = \", \".join([med.name for med in medications])\n                quick_prompt = f\"Can you remind me about my medications? I take: {med_list}\"\n                \n                response_data = st.session_state.companion_agent.generate_response(\n                    user_id=user_id,\n                    user_message=quick_prompt,\n                    conversation_type=\"medication\"\n                )\n                \n                st.session_state.chat_history.append({\"role\": \"user\", \"content\": quick_prompt, \"timestamp\": datetime.now()})\n                st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response_data[\"response\"], \"timestamp\": datetime.now()})\n                st.rerun()\n    \n    # Mood analysis\n    if st.session_state.get('show_mood_analysis', False):\n        st.subheader(\"üìà Conversation Mood Analysis\")\n        \n        conversations = ConversationCRUD.get_recent_sentiment_data(user_id, days=7)\n        if conversations:\n            # Create sentiment chart\n            df = pd.DataFrame([\n                {\n                    \"timestamp\": conv.timestamp,\n                    \"sentiment_score\": conv.sentiment_score,\n                    \"sentiment_label\": conv.sentiment_label\n                }\n                for conv in conversations\n                if conv.sentiment_score is not None\n            ])\n            \n            fig = px.line(\n                df, x=\"timestamp\", y=\"sentiment_score\",\n                title=\"Mood Trends Over Time\",\n                color_discrete_sequence=[\"#1f77b4\"]\n            )\n            fig.add_hline(y=0, line_dash=\"dash\", line_color=\"gray\")\n            fig.update_layout(\n                yaxis_title=\"Mood Score\",\n                xaxis_title=\"Time\",\n                yaxis_range=[-1, 1]\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No mood data available yet. Keep chatting with Carely!\")\n\ndef show_medication_management(user_id: int):\n    \"\"\"Show medication management interface\"\"\"\n    user = UserCRUD.get_user(user_id)\n    st.header(f\"üíä Medication Management - {user.name}\")\n    \n    # Medication overview\n    medications = MedicationCRUD.get_user_medications(user_id)\n    \n    if medications:\n        st.subheader(\"Current Medications\")\n        \n        for med in medications:\n            with st.expander(f\"{med.name} - {med.dosage}\"):\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.write(f\"**Frequency:** {med.frequency}\")\n                    if med.schedule_times:\n                        times = json.loads(med.schedule_times)\n                        st.write(f\"**Times:** {', '.join(times)}\")\n                    if med.instructions:\n                        st.write(f\"**Instructions:** {med.instructions}\")\n                    st.write(f\"**Active:** {'Yes' if med.active else 'No'}\")\n                \n                with col2:\n                    # Recent logs for this medication\n                    adherence = MedicationLogCRUD.get_medication_adherence(user_id, days=7)\n                    med_logs = [log for log in adherence.get(\"logs\", []) if log.medication_id == med.id]\n                    \n                    if med_logs:\n                        st.write(\"**Recent Activity:**\")\n                        for log in med_logs[-3:]:  # Last 3 logs\n                            status_emoji = \"‚úÖ\" if log.status == \"taken\" else \"‚ùå\" if log.status == \"missed\" else \"‚è∏Ô∏è\"\n                            st.write(f\"{status_emoji} {log.scheduled_time.strftime('%m/%d %I:%M %p')} - {log.status}\")\n                    \n                    # Quick log button\n                    if st.button(f\"Log {med.name} as Taken\", key=f\"log_{med.id}\"):\n                        MedicationLogCRUD.log_medication_taken(\n                            user_id=user_id,\n                            medication_id=med.id,\n                            scheduled_time=datetime.now(),\n                            status=\"taken\"\n                        )\n                        st.success(f\"{med.name} logged as taken!\")\n                        st.rerun()\n    \n    else:\n        st.info(\"No medications found. Add medications below.\")\n    \n    st.divider()\n    \n    # Medication adherence chart\n    st.subheader(\"üìä Adherence Overview\")\n    \n    # Time period selector\n    period = st.selectbox(\"Select period:\", [\"Last 7 days\", \"Last 30 days\"], key=\"adherence_period\")\n    days = 7 if period == \"Last 7 days\" else 30\n    \n    adherence = MedicationLogCRUD.get_medication_adherence(user_id, days=days)\n    \n    col1, col2, col3 = st.columns(3)\n    with col1:\n        st.metric(\"Total Doses\", adherence.get(\"total\", 0))\n    with col2:\n        st.metric(\"Doses Taken\", adherence.get(\"taken\", 0))\n    with col3:\n        st.metric(\"Adherence Rate\", f\"{adherence.get('adherence_rate', 0):.1f}%\")\n    \n    # Adherence chart\n    if adherence.get(\"logs\"):\n        df = pd.DataFrame([\n            {\n                \"date\": log.scheduled_time.date(),\n                \"status\": log.status,\n                \"medication\": next((med.name for med in medications if med.id == log.medication_id), \"Unknown\")\n            }\n            for log in adherence[\"logs\"]\n        ])\n        \n        # Group by date and calculate daily adherence\n        daily_adherence = df.groupby(\"date\").apply(\n            lambda x: (x[\"status\"] == \"taken\").sum() / len(x) * 100\n        ).reset_index(name=\"adherence_rate\")\n        daily_adherence[\"date\"] = pd.to_datetime(daily_adherence[\"date\"])\n        \n        fig = px.line(\n            daily_adherence, \n            x=\"date\", \n            y=\"adherence_rate\",\n            title=f\"Daily Adherence Rate ({period})\",\n            range_y=[0, 100]\n        )\n        fig.add_hline(y=80, line_dash=\"dash\", line_color=\"orange\", annotation_text=\"Target: 80%\")\n        fig.update_layout(yaxis_title=\"Adherence Rate (%)\", xaxis_title=\"Date\")\n        \n        st.plotly_chart(fig, use_container_width=True)\n    \n    st.divider()\n    \n    # Add new medication\n    st.subheader(\"‚ûï Add New Medication\")\n    \n    with st.form(\"add_medication\"):\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            med_name = st.text_input(\"Medication Name*\")\n            dosage = st.text_input(\"Dosage*\", placeholder=\"e.g., 10mg, 1 tablet\")\n            frequency = st.selectbox(\"Frequency\", [\"daily\", \"twice_daily\", \"three_times_daily\", \"weekly\", \"as_needed\"])\n        \n        with col2:\n            # Schedule times\n            if frequency == \"daily\":\n                times = [st.time_input(\"Time\", value=time(9, 0)).strftime(\"%H:%M\")]\n            elif frequency == \"twice_daily\":\n                time1 = st.time_input(\"Morning\", value=time(9, 0)).strftime(\"%H:%M\")\n                time2 = st.time_input(\"Evening\", value=time(21, 0)).strftime(\"%H:%M\")\n                times = [time1, time2]\n            elif frequency == \"three_times_daily\":\n                time1 = st.time_input(\"Morning\", value=time(8, 0)).strftime(\"%H:%M\")\n                time2 = st.time_input(\"Afternoon\", value=time(14, 0)).strftime(\"%H:%M\")\n                time3 = st.time_input(\"Evening\", value=time(20, 0)).strftime(\"%H:%M\")\n                times = [time1, time2, time3]\n            else:\n                times = []\n        \n        instructions = st.text_area(\"Instructions (optional)\", placeholder=\"Take with food, etc.\")\n        \n        if st.form_submit_button(\"Add Medication\"):\n            if med_name and dosage:\n                try:\n                    MedicationCRUD.create_medication(\n                        user_id=user_id,\n                        name=med_name,\n                        dosage=dosage,\n                        frequency=frequency,\n                        schedule_times=times,\n                        instructions=instructions or None\n                    )\n                    st.success(f\"Added {med_name} successfully!\")\n                    st.rerun()\n                except Exception as e:\n                    st.error(f\"Error adding medication: {e}\")\n            else:\n                st.error(\"Please fill in required fields (Name and Dosage)\")\n\ndef show_health_insights(user_id: int):\n    \"\"\"Show health insights and analytics\"\"\"\n    user = UserCRUD.get_user(user_id)\n    st.header(f\"üìä Health Insights - {user.name}\")\n    \n    # Time period selector\n    col1, col2 = st.columns([1, 3])\n    with col1:\n        period = st.selectbox(\"Time Period:\", [\"7 days\", \"30 days\", \"90 days\"])\n        days = int(period.split()[0])\n    \n    # Get data\n    conversations = ConversationCRUD.get_recent_sentiment_data(user_id, days=days)\n    adherence = MedicationLogCRUD.get_medication_adherence(user_id, days=days)\n    \n    # Summary metrics\n    st.subheader(\"üìà Summary\")\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        if conversations:\n            avg_mood = sum(c.sentiment_score for c in conversations if c.sentiment_score) / len([c for c in conversations if c.sentiment_score])\n            mood_emoji = get_sentiment_emoji(avg_mood)\n            st.metric(\"Average Mood\", f\"{mood_emoji} {avg_mood:.2f}\")\n        else:\n            st.metric(\"Average Mood\", \"No data\")\n    \n    with col2:\n        st.metric(\"Medication Adherence\", f\"{adherence.get('adherence_rate', 0):.1f}%\")\n    \n    with col3:\n        st.metric(\"Total Conversations\", len(conversations))\n    \n    with col4:\n        alerts = CaregiverAlertCRUD.get_unresolved_alerts(user_id)\n        st.metric(\"Active Concerns\", len(alerts))\n    \n    st.divider()\n    \n    # Charts\n    if conversations:\n        # Mood trend chart\n        st.subheader(\"üòä Mood Trends\")\n        \n        df_mood = pd.DataFrame([\n            {\n                \"date\": conv.timestamp.date(),\n                \"sentiment_score\": conv.sentiment_score,\n                \"sentiment_label\": conv.sentiment_label\n            }\n            for conv in conversations\n            if conv.sentiment_score is not None\n        ])\n        \n        # Daily average mood\n        daily_mood = df_mood.groupby(\"date\")[\"sentiment_score\"].mean().reset_index()\n        daily_mood[\"date\"] = pd.to_datetime(daily_mood[\"date\"])\n        \n        fig_mood = px.line(\n            daily_mood, \n            x=\"date\", \n            y=\"sentiment_score\",\n            title=\"Daily Average Mood\",\n            range_y=[-1, 1]\n        )\n        fig_mood.add_hline(y=0, line_dash=\"dash\", line_color=\"gray\")\n        fig_mood.add_hline(y=0.3, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Good mood\")\n        fig_mood.add_hline(y=-0.3, line_dash=\"dot\", line_color=\"red\", annotation_text=\"Concerning\")\n        \n        st.plotly_chart(fig_mood, use_container_width=True)\n        \n        # Sentiment distribution\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            sentiment_counts = df_mood[\"sentiment_label\"].value_counts()\n            fig_pie = px.pie(\n                values=sentiment_counts.values,\n                names=sentiment_counts.index,\n                title=\"Mood Distribution\"\n            )\n            st.plotly_chart(fig_pie, use_container_width=True)\n        \n        with col2:\n            # Most active times\n            df_mood_with_hour = pd.DataFrame([\n                {\n                    \"hour\": conv.timestamp.hour,\n                    \"sentiment_score\": conv.sentiment_score\n                }\n                for conv in conversations\n                if conv.sentiment_score is not None\n            ])\n            \n            if not df_mood_with_hour.empty:\n                hourly_mood = df_mood_with_hour.groupby(\"hour\")[\"sentiment_score\"].mean().reset_index()\n                fig_hourly = px.bar(\n                    hourly_mood,\n                    x=\"hour\",\n                    y=\"sentiment_score\",\n                    title=\"Mood by Time of Day\"\n                )\n                fig_hourly.update_xaxis(dtick=1)\n                st.plotly_chart(fig_hourly, use_container_width=True)\n    \n    # Medication insights\n    if adherence.get(\"logs\"):\n        st.subheader(\"üíä Medication Insights\")\n        \n        # Weekly adherence pattern\n        df_med = pd.DataFrame([\n            {\n                \"date\": log.scheduled_time.date(),\n                \"day_of_week\": log.scheduled_time.strftime(\"%A\"),\n                \"status\": log.status,\n                \"hour\": log.scheduled_time.hour\n            }\n            for log in adherence[\"logs\"]\n        ])\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            # Adherence by day of week\n            weekly_adherence = df_med.groupby(\"day_of_week\").apply(\n                lambda x: (x[\"status\"] == \"taken\").sum() / len(x) * 100\n            ).reset_index(name=\"adherence_rate\")\n            \n            # Order by day of week\n            day_order = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n            weekly_adherence[\"day_of_week\"] = pd.Categorical(weekly_adherence[\"day_of_week\"], categories=day_order, ordered=True)\n            weekly_adherence = weekly_adherence.sort_values(\"day_of_week\")\n            \n            fig_weekly = px.bar(\n                weekly_adherence,\n                x=\"day_of_week\",\n                y=\"adherence_rate\",\n                title=\"Adherence by Day of Week\"\n            )\n            st.plotly_chart(fig_weekly, use_container_width=True)\n        \n        with col2:\n            # Adherence by time of day\n            hourly_adherence = df_med.groupby(\"hour\").apply(\n                lambda x: (x[\"status\"] == \"taken\").sum() / len(x) * 100\n            ).reset_index(name=\"adherence_rate\")\n            \n            fig_hourly_med = px.bar(\n                hourly_adherence,\n                x=\"hour\",\n                y=\"adherence_rate\",\n                title=\"Adherence by Time of Day\"\n            )\n            st.plotly_chart(fig_hourly_med, use_container_width=True)\n    \n    # Health recommendations\n    st.subheader(\"üí° Health Recommendations\")\n    \n    recommendations = []\n    \n    if conversations:\n        recent_mood = [c.sentiment_score for c in conversations[-7:] if c.sentiment_score is not None]\n        if recent_mood:\n            avg_recent_mood = sum(recent_mood) / len(recent_mood)\n            if avg_recent_mood < -0.3:\n                recommendations.append(\"üü° Recent mood trends show concern. Consider scheduling a check-in with healthcare provider.\")\n            elif avg_recent_mood > 0.3:\n                recommendations.append(\"üü¢ Mood trends are positive! Keep up the good routine.\")\n    \n    if adherence.get(\"adherence_rate\", 100) < 80:\n        recommendations.append(\"üî¥ Medication adherence is below 80%. Consider setting more reminders or reviewing medication schedule.\")\n    elif adherence.get(\"adherence_rate\", 100) > 90:\n        recommendations.append(\"üü¢ Excellent medication adherence! Keep up the great work.\")\n    \n    if len(conversations) < 7 and days >= 7:\n        recommendations.append(\"üü° Consider chatting with Carely more regularly for better mood tracking.\")\n    \n    if not recommendations:\n        recommendations.append(\"üü¢ All health metrics look good! Continue current routine.\")\n    \n    for rec in recommendations:\n        st.write(rec)\n\ndef show_alerts_and_reminders(user_id: int):\n    \"\"\"Show alerts and reminders interface\"\"\"\n    user = UserCRUD.get_user(user_id)\n    st.header(f\"üö® Alerts & Reminders - {user.name}\")\n    \n    # Tabs for different types\n    tab1, tab2, tab3 = st.tabs([\"üîî Pending Reminders\", \"üö® Active Alerts\", \"üìã Reminder History\"])\n    \n    with tab1:\n        st.subheader(\"Pending Reminders\")\n        \n        reminders = ReminderCRUD.get_pending_reminders(user_id)\n        \n        if reminders:\n            for reminder in reminders:\n                with st.container():\n                    col1, col2 = st.columns([3, 1])\n                    \n                    with col1:\n                        # Color code by type\n                        if reminder.reminder_type == \"medication\":\n                            st.markdown(f\"üíä **{reminder.title}**\")\n                        elif reminder.reminder_type == \"checkin\":\n                            st.markdown(f\"üí¨ **{reminder.title}**\")\n                        else:\n                            st.markdown(f\"üìÖ **{reminder.title}**\")\n                        \n                        st.write(reminder.message)\n                        st.caption(f\"Scheduled: {reminder.scheduled_time.strftime('%m/%d/%Y %I:%M %p')}\")\n                    \n                    with col2:\n                        if st.button(\"‚úÖ Complete\", key=f\"complete_{reminder.id}\"):\n                            ReminderCRUD.complete_reminder(reminder.id)\n                            st.success(\"Reminder completed!\")\n                            st.rerun()\n                    \n                    st.divider()\n        else:\n            st.info(\"No pending reminders\")\n    \n    with tab2:\n        st.subheader(\"Active Alerts\")\n        \n        alerts = CaregiverAlertCRUD.get_unresolved_alerts(user_id)\n        \n        if alerts:\n            for alert in alerts:\n                with st.container():\n                    # Color code by severity\n                    if alert.severity == \"high\":\n                        st.error(f\"üî¥ **{alert.title}**\")\n                    elif alert.severity == \"medium\":\n                        st.warning(f\"üü° **{alert.title}**\")\n                    else:\n                        st.info(f\"üü¢ **{alert.title}**\")\n                    \n                    st.write(alert.description)\n                    st.caption(f\"Created: {alert.created_at.strftime('%m/%d/%Y %I:%M %p')} | Type: {alert.alert_type}\")\n                    \n                    col1, col2 = st.columns([1, 1])\n                    with col1:\n                        if st.button(\"‚úÖ Resolve\", key=f\"resolve_{alert.id}\"):\n                            CaregiverAlertCRUD.resolve_alert(alert.id)\n                            st.success(\"Alert resolved!\")\n                            st.rerun()\n                    \n                    st.divider()\n        else:\n            st.success(\"No active alerts - all good! ‚ú®\")\n    \n    with tab3:\n        st.subheader(\"Reminder History\")\n        \n        # This would show completed reminders and resolved alerts\n        # For now, showing a simple message\n        st.info(\"Reminder history feature coming soon!\")\n        \n        # Could add filters for date range, type, etc.\n        col1, col2, col3 = st.columns(3)\n        with col1:\n            st.selectbox(\"Filter by Type:\", [\"All\", \"Medication\", \"Check-in\", \"Custom\"])\n        with col2:\n            st.selectbox(\"Filter by Status:\", [\"All\", \"Completed\", \"Missed\"])\n        with col3:\n            st.selectbox(\"Time Period:\", [\"Last 7 days\", \"Last 30 days\", \"All time\"])\n\ndef show_user_management():\n    \"\"\"Show user management interface\"\"\"\n    st.header(\"üë• User Management\")\n    \n    # Current users\n    users = UserCRUD.get_all_users()\n    \n    if users:\n        st.subheader(\"Current Users\")\n        \n        for user in users:\n            with st.expander(f\"{user.name} (ID: {user.id})\"):\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.write(f\"**Name:** {user.name}\")\n                    st.write(f\"**Email:** {user.email or 'Not provided'}\")\n                    st.write(f\"**Phone:** {user.phone or 'Not provided'}\")\n                    st.write(f\"**Emergency Contact:** {user.emergency_contact or 'Not provided'}\")\n                \n                with col2:\n                    st.write(f\"**Created:** {user.created_at.strftime('%m/%d/%Y')}\")\n                    if user.preferences:\n                        try:\n                            prefs = json.loads(user.preferences)\n                            st.write(\"**Preferences:**\")\n                            for key, value in prefs.items():\n                                st.write(f\"- {key}: {value}\")\n                        except:\n                            st.write(\"**Preferences:** Invalid format\")\n                    \n                    # Quick stats\n                    conversations = ConversationCRUD.get_user_conversations(user.id, limit=1)\n                    medications = MedicationCRUD.get_user_medications(user.id)\n                    st.write(f\"**Medications:** {len(medications)}\")\n                    st.write(f\"**Last Chat:** {conversations[0].timestamp.strftime('%m/%d/%Y') if conversations else 'Never'}\")\n    \n    st.divider()\n    \n    # Add new user\n    st.subheader(\"‚ûï Add New User\")\n    \n    with st.form(\"add_user\"):\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            name = st.text_input(\"Full Name*\")\n            email = st.text_input(\"Email\")\n            phone = st.text_input(\"Phone Number\")\n        \n        with col2:\n            emergency_contact = st.text_input(\"Emergency Contact\")\n            \n            # Preferences\n            st.write(\"**Preferences:**\")\n            pref_language = st.selectbox(\"Preferred Language:\", [\"English\", \"Spanish\", \"French\", \"Other\"])\n            pref_time = st.selectbox(\"Preferred Contact Time:\", [\"Morning\", \"Afternoon\", \"Evening\", \"Any\"])\n            pref_reminders = st.checkbox(\"Enable Reminders\", value=True)\n        \n        if st.form_submit_button(\"Add User\"):\n            if name:\n                try:\n                    preferences = {\n                        \"language\": pref_language,\n                        \"contact_time\": pref_time,\n                        \"reminders_enabled\": pref_reminders\n                    }\n                    \n                    new_user = UserCRUD.create_user(\n                        name=name,\n                        email=email or None,\n                        phone=phone or None,\n                        preferences=preferences,\n                        emergency_contact=emergency_contact or None\n                    )\n                    \n                    st.success(f\"Added user {name} successfully! (ID: {new_user.id})\")\n                    st.rerun()\n                \n                except Exception as e:\n                    st.error(f\"Error adding user: {e}\")\n            else:\n                st.error(\"Please enter a name\")\n    \n    # User statistics\n    if users:\n        st.divider()\n        st.subheader(\"üìä User Statistics\")\n        \n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Total Users\", len(users))\n        \n        with col2:\n            # Users with medications\n            users_with_meds = 0\n            for user in users:\n                if MedicationCRUD.get_user_medications(user.id):\n                    users_with_meds += 1\n            st.metric(\"Users with Medications\", users_with_meds)\n        \n        with col3:\n            # Users with recent activity (last 7 days)\n            active_users = 0\n            for user in users:\n                conversations = ConversationCRUD.get_user_conversations(user.id, limit=1)\n                if conversations and (datetime.now() - conversations[0].timestamp).days <= 7:\n                    active_users += 1\n            st.metric(\"Active Users (7d)\", active_users)\n        \n        with col4:\n            # Users with alerts\n            users_with_alerts = 0\n            for user in users:\n                alerts = CaregiverAlertCRUD.get_unresolved_alerts(user.id)\n                if alerts:\n                    users_with_alerts += 1\n            st.metric(\"Users with Alerts\", users_with_alerts)\n","size_bytes":35481},"app/memory/conversation_store.py":{"content":"from typing import List, Dict, Any, Optional\nfrom datetime import datetime, timedelta\nimport json\nfrom app.database.crud import ConversationCRUD\n\nclass ConversationMemoryStore:\n    \"\"\"\n    Handles conversation memory and context for the AI companion\n    \"\"\"\n    \n    def __init__(self, user_id: int, max_memory_days: int = 30):\n        self.user_id = user_id\n        self.max_memory_days = max_memory_days\n    \n    def get_conversation_summary(self, days: int = 7) -> str:\n        \"\"\"Get a summary of recent conversations for context\"\"\"\n        conversations = ConversationCRUD.get_user_conversations(\n            self.user_id, \n            limit=50\n        )\n        \n        # Filter by date\n        cutoff_date = datetime.now() - timedelta(days=days)\n        recent_convs = [\n            conv for conv in conversations \n            if conv.timestamp >= cutoff_date\n        ]\n        \n        if not recent_convs:\n            return \"No recent conversations found.\"\n        \n        # Group conversations by day\n        daily_summaries = {}\n        for conv in recent_convs:\n            date_key = conv.timestamp.date()\n            if date_key not in daily_summaries:\n                daily_summaries[date_key] = []\n            daily_summaries[date_key].append(conv)\n        \n        # Create summary\n        summary = f\"Conversation summary for {self.user_id} (last {days} days):\\n\\n\"\n        \n        for date, convs in sorted(daily_summaries.items(), reverse=True):\n            summary += f\"=== {date.strftime('%B %d, %Y')} ===\\n\"\n            \n            # Sentiment analysis for the day\n            sentiments = [c.sentiment_score for c in convs if c.sentiment_score is not None]\n            if sentiments:\n                avg_sentiment = sum(sentiments) / len(sentiments)\n                sentiment_desc = self._sentiment_to_description(avg_sentiment)\n                summary += f\"Overall mood: {sentiment_desc}\\n\"\n            \n            # Key topics/concerns\n            topics = self._extract_topics(convs)\n            if topics:\n                summary += f\"Topics discussed: {', '.join(topics)}\\n\"\n            \n            # Medication mentions\n            med_mentions = self._extract_medication_mentions(convs)\n            if med_mentions:\n                summary += f\"Medications mentioned: {', '.join(med_mentions)}\\n\"\n            \n            summary += \"\\n\"\n        \n        return summary\n    \n    def get_important_context(self) -> Dict[str, Any]:\n        \"\"\"Get important contextual information about the user\"\"\"\n        conversations = ConversationCRUD.get_user_conversations(self.user_id, limit=100)\n        \n        context = {\n            \"mood_patterns\": self._analyze_mood_patterns(conversations),\n            \"medication_patterns\": self._analyze_medication_patterns(conversations),\n            \"common_concerns\": self._extract_common_concerns(conversations),\n            \"preferred_topics\": self._extract_preferred_topics(conversations),\n            \"communication_style\": self._analyze_communication_style(conversations)\n        }\n        \n        return context\n    \n    def _sentiment_to_description(self, score: float) -> str:\n        \"\"\"Convert sentiment score to human-readable description\"\"\"\n        if score > 0.6:\n            return \"Very positive\"\n        elif score > 0.2:\n            return \"Positive\"\n        elif score > -0.2:\n            return \"Neutral\"\n        elif score > -0.6:\n            return \"Somewhat negative\"\n        else:\n            return \"Concerning/negative\"\n    \n    def _extract_topics(self, conversations: List) -> List[str]:\n        \"\"\"Extract main topics from conversations\"\"\"\n        # Simple keyword extraction - could be enhanced with NLP\n        topic_keywords = {\n            \"health\": [\"pain\", \"doctor\", \"hospital\", \"medicine\", \"sick\", \"health\", \"feel\"],\n            \"family\": [\"family\", \"children\", \"grandchildren\", \"spouse\", \"daughter\", \"son\"],\n            \"activities\": [\"walk\", \"exercise\", \"garden\", \"read\", \"watch\", \"hobby\"],\n            \"sleep\": [\"sleep\", \"tired\", \"rest\", \"bed\", \"night\"],\n            \"food\": [\"eat\", \"food\", \"hungry\", \"meal\", \"cook\", \"dinner\", \"lunch\"],\n            \"social\": [\"friend\", \"visit\", \"call\", \"lonely\", \"social\", \"people\"]\n        }\n        \n        found_topics = set()\n        all_text = \" \".join([conv.message.lower() for conv in conversations])\n        \n        for topic, keywords in topic_keywords.items():\n            if any(keyword in all_text for keyword in keywords):\n                found_topics.add(topic)\n        \n        return list(found_topics)\n    \n    def _extract_medication_mentions(self, conversations: List) -> List[str]:\n        \"\"\"Extract medication names mentioned in conversations\"\"\"\n        medications = set()\n        \n        # Common medication keywords\n        med_indicators = [\"pill\", \"medication\", \"medicine\", \"dose\", \"tablet\", \"take\", \"prescribed\"]\n        \n        for conv in conversations:\n            text_lower = conv.message.lower()\n            # If medication indicators are present, look for potential drug names\n            if any(indicator in text_lower for indicator in med_indicators):\n                # This is a simplified approach - in production, you'd use medical NLP\n                words = text_lower.split()\n                for word in words:\n                    if len(word) > 4 and not word in [\"medicine\", \"medication\", \"tablet\", \"prescribed\"]:\n                        # Basic filtering for potential medication names\n                        medications.add(word.capitalize())\n        \n        return list(medications)[:5]  # Return top 5\n    \n    def _analyze_mood_patterns(self, conversations: List) -> Dict[str, Any]:\n        \"\"\"Analyze mood patterns over time\"\"\"\n        if not conversations:\n            return {}\n        \n        sentiments = [c.sentiment_score for c in conversations if c.sentiment_score is not None]\n        if not sentiments:\n            return {}\n        \n        return {\n            \"average_mood\": sum(sentiments) / len(sentiments),\n            \"mood_trend\": \"improving\" if sentiments[-5:] > sentiments[:5] else \"stable\",\n            \"total_conversations\": len(conversations),\n            \"sentiment_distribution\": {\n                \"positive\": len([s for s in sentiments if s > 0.2]),\n                \"neutral\": len([s for s in sentiments if -0.2 <= s <= 0.2]),\n                \"negative\": len([s for s in sentiments if s < -0.2])\n            }\n        }\n    \n    def _analyze_medication_patterns(self, conversations: List) -> Dict[str, Any]:\n        \"\"\"Analyze medication-related conversation patterns\"\"\"\n        med_conversations = [\n            c for c in conversations \n            if c.conversation_type == \"medication\" or \n               any(word in c.message.lower() for word in [\"medication\", \"pill\", \"medicine\", \"dose\"])\n        ]\n        \n        return {\n            \"medication_discussions\": len(med_conversations),\n            \"recent_medication_concerns\": len([\n                c for c in med_conversations[-10:] \n                if c.sentiment_score and c.sentiment_score < -0.3\n            ])\n        }\n    \n    def _extract_common_concerns(self, conversations: List) -> List[str]:\n        \"\"\"Extract common concerns or recurring themes\"\"\"\n        concern_keywords = {\n            \"pain\": [\"pain\", \"hurt\", \"ache\", \"sore\"],\n            \"sleep\": [\"sleep\", \"insomnia\", \"tired\", \"rest\"],\n            \"loneliness\": [\"lonely\", \"alone\", \"isolated\", \"miss\"],\n            \"confusion\": [\"confused\", \"forgot\", \"remember\", \"memory\"],\n            \"anxiety\": [\"worried\", \"anxious\", \"scared\", \"nervous\"]\n        }\n        \n        concerns = {}\n        all_messages = \" \".join([conv.message.lower() for conv in conversations])\n        \n        for concern, keywords in concern_keywords.items():\n            count = sum(all_messages.count(keyword) for keyword in keywords)\n            if count > 0:\n                concerns[concern] = count\n        \n        # Return top concerns\n        return sorted(concerns.keys(), key=lambda x: concerns[x], reverse=True)[:3]\n    \n    def _extract_preferred_topics(self, conversations: List) -> List[str]:\n        \"\"\"Extract topics the user seems to enjoy discussing\"\"\"\n        positive_convs = [\n            c for c in conversations \n            if c.sentiment_score and c.sentiment_score > 0.3\n        ]\n        \n        return self._extract_topics(positive_convs)[:3]\n    \n    def _analyze_communication_style(self, conversations: List) -> Dict[str, Any]:\n        \"\"\"Analyze the user's communication preferences\"\"\"\n        if not conversations:\n            return {}\n        \n        total_chars = sum(len(conv.message) for conv in conversations)\n        avg_message_length = total_chars / len(conversations)\n        \n        return {\n            \"average_message_length\": avg_message_length,\n            \"prefers_short_messages\": avg_message_length < 50,\n            \"total_conversations\": len(conversations),\n            \"most_active_time\": self._find_most_active_time(conversations)\n        }\n    \n    def _find_most_active_time(self, conversations: List) -> str:\n        \"\"\"Find when the user is most active in conversations\"\"\"\n        if not conversations:\n            return \"unknown\"\n        \n        time_counts = {\"morning\": 0, \"afternoon\": 0, \"evening\": 0, \"night\": 0}\n        \n        for conv in conversations:\n            hour = conv.timestamp.hour\n            if 6 <= hour < 12:\n                time_counts[\"morning\"] += 1\n            elif 12 <= hour < 17:\n                time_counts[\"afternoon\"] += 1\n            elif 17 <= hour < 22:\n                time_counts[\"evening\"] += 1\n            else:\n                time_counts[\"night\"] += 1\n        \n        return max(time_counts.keys(), key=lambda x: time_counts[x])\n","size_bytes":9769},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"apscheduler>=3.11.0\",\n    \"fastapi>=0.118.0\",\n    \"openai>=2.2.0\",\n    \"plotly>=6.3.1\",\n    \"sqlmodel>=0.0.25\",\n    \"streamlit-mic-recorder>=0.0.8\",\n    \"streamlit>=1.50.0\",\n]\n","size_bytes":323},"app/database/models.py":{"content":"from sqlmodel import SQLModel, Field, create_engine, Session\nfrom datetime import datetime, time\nfrom typing import Optional, List\nimport sqlite3\n\n# Database setup\nDATABASE_URL = \"sqlite:///carely.db\"\nengine = create_engine(DATABASE_URL, echo=False)\n\nclass User(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str\n    email: Optional[str] = None\n    phone: Optional[str] = None\n    preferences: Optional[str] = None  # JSON string for preferences\n    emergency_contact: Optional[str] = None\n    telegram_chat_id: Optional[str] = None  # Telegram chat ID for notifications\n    user_type: str = Field(default=\"patient\")  # patient, caregiver, admin\n    password_hash: Optional[str] = None\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass Medication(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    name: str\n    dosage: str\n    frequency: str  # e.g., \"daily\", \"twice_daily\", \"weekly\"\n    schedule_times: str  # JSON string of times like [\"09:00\", \"21:00\"]\n    instructions: Optional[str] = None\n    active: bool = Field(default=True)\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass Conversation(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    message: str\n    response: str\n    sentiment_score: Optional[float] = None  # -1 to 1 scale\n    sentiment_label: Optional[str] = None  # positive, negative, neutral\n    conversation_type: str = Field(default=\"general\")  # general, checkin, medication\n    timestamp: datetime = Field(default_factory=datetime.now)\n\nclass Reminder(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    reminder_type: str  # medication, checkin, alert\n    title: str\n    message: str\n    scheduled_time: datetime\n    completed: bool = Field(default=False)\n    completed_at: Optional[datetime] = None\n    medication_id: Optional[int] = Field(default=None, foreign_key=\"medication.id\")\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass MedicationLog(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    medication_id: int = Field(foreign_key=\"medication.id\")\n    scheduled_time: datetime\n    taken_time: Optional[datetime] = None\n    status: str = Field(default=\"pending\")  # pending, taken, missed, skipped\n    notes: Optional[str] = None\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass CaregiverAlert(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    alert_type: str  # medication_missed, mood_concern, emergency\n    severity: str = Field(default=\"medium\")  # low, medium, high\n    title: str\n    description: str\n    resolved: bool = Field(default=False)\n    resolved_at: Optional[datetime] = None\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass CaregiverPatientAssignment(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    caregiver_id: int = Field(foreign_key=\"user.id\")\n    patient_id: int = Field(foreign_key=\"user.id\")\n    relationship: Optional[str] = None  # family, professional, friend\n    notification_preferences: Optional[str] = None  # JSON string\n    created_at: datetime = Field(default_factory=datetime.now)\n\nclass PersonalEvent(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"user.id\")\n    event_type: str  # birthday, appointment, family_event, hobby, achievement\n    title: str\n    description: Optional[str] = None\n    event_date: Optional[datetime] = None\n    recurring: bool = Field(default=False)\n    importance: str = Field(default=\"medium\")  # low, medium, high\n    created_at: datetime = Field(default_factory=datetime.now)\n\ndef create_tables():\n    \"\"\"Create all database tables\"\"\"\n    SQLModel.metadata.create_all(engine)\n\ndef get_session():\n    \"\"\"Get database session\"\"\"\n    return Session(engine)\n","size_bytes":4249},"main.py":{"content":"import streamlit as st\nimport asyncio\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom app.database.models import create_tables\nfrom app.scheduling.reminder_scheduler import ReminderScheduler\nfrom frontend.dashboard import run_dashboard\nfrom frontend.caregiver_portal import show_caregiver_dashboard\nfrom data.sample_data import initialize_sample_data\n\n# Initialize the database and sample data on startup\n@st.cache_resource\ndef initialize_app():\n    \"\"\"Initialize the application with database and sample data\"\"\"\n    create_tables()\n    initialize_sample_data()\n    \n    # Start the reminder scheduler in a separate thread\n    scheduler = ReminderScheduler()\n    scheduler_thread = threading.Thread(target=scheduler.start, daemon=True)\n    scheduler_thread.start()\n    \n    return scheduler\n\ndef main():\n    st.set_page_config(\n        page_title=\"Carely - AI Companion for Elderly Care\",\n        page_icon=\"üè•\",\n        layout=\"wide\",\n        initial_sidebar_state=\"expanded\"\n    )\n    \n    # Initialize the app\n    scheduler = initialize_app()\n    \n    # Portal selector in sidebar\n    if \"caregiver_id\" not in st.session_state:\n        with st.sidebar:\n            st.header(\"üö™ Portal Selection\")\n            portal = st.radio(\"Choose portal:\", [\"üë§ Patient Portal\", \"üë®‚Äç‚öïÔ∏è Caregiver Portal\"])\n            \n            if portal == \"üë®‚Äç‚öïÔ∏è Caregiver Portal\":\n                show_caregiver_dashboard()\n                return\n    \n    # Run the appropriate dashboard\n    if \"caregiver_id\" in st.session_state:\n        show_caregiver_dashboard()\n    else:\n        run_dashboard()\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":1669},"data/sample_data.py":{"content":"import json\nfrom datetime import datetime, timedelta, time\nfrom app.database.models import create_tables\nfrom app.database.crud import (\n    UserCRUD, MedicationCRUD, ConversationCRUD, ReminderCRUD,\n    MedicationLogCRUD, CaregiverAlertCRUD, CaregiverPatientCRUD, PersonalEventCRUD\n)\n\ndef initialize_sample_data():\n    \"\"\"Initialize the database with sample data for testing\"\"\"\n    \n    # Check if data already exists\n    existing_users = UserCRUD.get_all_users()\n    if existing_users:\n        print(\"Sample data already exists, skipping initialization\")\n        return\n    \n    try:\n        print(\"Initializing sample data...\")\n        \n        # Create sample users\n        user1 = UserCRUD.create_user(\n            name=\"Dorothy Johnson\",\n            email=\"dorothy.johnson@email.com\",\n            phone=\"555-0123\",\n            preferences={\n                \"language\": \"English\",\n                \"contact_time\": \"Morning\",\n                \"reminders_enabled\": True,\n                \"preferred_topics\": [\"family\", \"gardening\", \"cooking\"]\n            },\n            emergency_contact=\"John Johnson (Son) - 555-0124\"\n        )\n        \n        user2 = UserCRUD.create_user(\n            name=\"Robert Chen\",\n            email=\"robert.chen@email.com\",\n            phone=\"555-0125\",\n            preferences={\n                \"language\": \"English\",\n                \"contact_time\": \"Afternoon\",\n                \"reminders_enabled\": True,\n                \"preferred_topics\": [\"reading\", \"chess\", \"music\"]\n            },\n            emergency_contact=\"Lisa Chen (Daughter) - 555-0126\"\n        )\n        \n        print(f\"Created users: {user1.name} (ID: {user1.id}), {user2.name} (ID: {user2.id})\")\n        \n        # Create sample caregivers\n        caregiver1 = UserCRUD.create_user(\n            name=\"Sarah Miller\",\n            email=\"sarah.miller@carely.com\",\n            phone=\"555-0200\",\n            user_type=\"caregiver\",\n            password=\"caregiver123\",\n            preferences={\n                \"notification_preferences\": \"email_and_sms\"\n            }\n        )\n        \n        caregiver2 = UserCRUD.create_user(\n            name=\"Dr. James Wilson\",\n            email=\"james.wilson@carely.com\",\n            phone=\"555-0201\",\n            user_type=\"caregiver\",\n            password=\"caregiver123\",\n            preferences={\n                \"notification_preferences\": \"email\"\n            }\n        )\n        \n        print(f\"Created caregivers: {caregiver1.name} (ID: {caregiver1.id}), {caregiver2.name} (ID: {caregiver2.id})\")\n        \n        # Assign patients to caregivers\n        CaregiverPatientCRUD.assign_patient(\n            caregiver_id=caregiver1.id,\n            patient_id=user1.id,\n            relationship=\"family\",\n            notification_preferences={\"alerts\": True, \"weekly_reports\": True}\n        )\n        \n        CaregiverPatientCRUD.assign_patient(\n            caregiver_id=caregiver1.id,\n            patient_id=user2.id,\n            relationship=\"professional\",\n            notification_preferences={\"alerts\": True, \"weekly_reports\": True}\n        )\n        \n        CaregiverPatientCRUD.assign_patient(\n            caregiver_id=caregiver2.id,\n            patient_id=user2.id,\n            relationship=\"professional\",\n            notification_preferences={\"alerts\": True, \"weekly_reports\": False}\n        )\n        \n        print(\"Created caregiver-patient assignments\")\n        \n        # Create personal events for memory\n        PersonalEventCRUD.create_event(\n            user_id=user1.id,\n            event_type=\"family_event\",\n            title=\"Grandson's Birthday\",\n            description=\"Tommy turns 10 years old\",\n            event_date=datetime.now() + timedelta(days=15),\n            importance=\"high\"\n        )\n        \n        PersonalEventCRUD.create_event(\n            user_id=user1.id,\n            event_type=\"appointment\",\n            title=\"Doctor's Appointment\",\n            description=\"Regular checkup with Dr. Smith\",\n            event_date=datetime.now() + timedelta(days=7),\n            importance=\"medium\"\n        )\n        \n        PersonalEventCRUD.create_event(\n            user_id=user2.id,\n            event_type=\"hobby\",\n            title=\"Chess Club Meeting\",\n            description=\"Weekly chess club at community center\",\n            event_date=datetime.now() + timedelta(days=3),\n            recurring=True,\n            importance=\"medium\"\n        )\n        \n        print(\"Created personal events\")\n        \n        # Create sample medications for user1 (Dorothy)\n        med1 = MedicationCRUD.create_medication(\n            user_id=user1.id,\n            name=\"Lisinopril\",\n            dosage=\"10mg\",\n            frequency=\"daily\",\n            schedule_times=[\"09:00\"],\n            instructions=\"Take with breakfast, monitor blood pressure\"\n        )\n        \n        med2 = MedicationCRUD.create_medication(\n            user_id=user1.id,\n            name=\"Metformin\",\n            dosage=\"500mg\",\n            frequency=\"twice_daily\",\n            schedule_times=[\"08:00\", \"20:00\"],\n            instructions=\"Take with meals to reduce stomach upset\"\n        )\n        \n        med3 = MedicationCRUD.create_medication(\n            user_id=user1.id,\n            name=\"Vitamin D\",\n            dosage=\"1000 IU\",\n            frequency=\"daily\",\n            schedule_times=[\"09:00\"],\n            instructions=\"Take with food for better absorption\"\n        )\n        \n        # Create sample medications for user2 (Robert)\n        med4 = MedicationCRUD.create_medication(\n            user_id=user2.id,\n            name=\"Atorvastatin\",\n            dosage=\"20mg\",\n            frequency=\"daily\",\n            schedule_times=[\"21:00\"],\n            instructions=\"Take in the evening, avoid grapefruit\"\n        )\n        \n        med5 = MedicationCRUD.create_medication(\n            user_id=user2.id,\n            name=\"Aspirin\",\n            dosage=\"81mg\",\n            frequency=\"daily\",\n            schedule_times=[\"09:00\"],\n            instructions=\"Low-dose aspirin for heart health\"\n        )\n        \n        print(f\"Created {5} sample medications\")\n        \n        # Create sample conversations with varying sentiments\n        sample_conversations_user1 = [\n            {\n                \"message\": \"Good morning Carely! I slept well last night and I'm feeling pretty good today.\",\n                \"response\": \"Good morning Dorothy! I'm so glad to hear you slept well and are feeling good today. That's wonderful news! How are you feeling about taking your medications this morning?\",\n                \"sentiment_score\": 0.7,\n                \"sentiment_label\": \"positive\",\n                \"conversation_type\": \"checkin\",\n                \"timestamp\": datetime.now() - timedelta(hours=2)\n            },\n            {\n                \"message\": \"I took my Lisinopril and Vitamin D with breakfast. The Metformin I'll take tonight.\",\n                \"response\": \"That's perfect, Dorothy! You're doing such a great job staying on top of your medications. Taking them with meals is exactly right. How has your appetite been lately?\",\n                \"sentiment_score\": 0.4,\n                \"sentiment_label\": \"positive\",\n                \"conversation_type\": \"medication\",\n                \"timestamp\": datetime.now() - timedelta(hours=1, minutes=45)\n            },\n            {\n                \"message\": \"My grandson called me yesterday and we talked for an hour. It made me so happy!\",\n                \"response\": \"Oh Dorothy, that's absolutely wonderful! Family connections are so precious. What did you and your grandson talk about? I love hearing about these special moments.\",\n                \"sentiment_score\": 0.8,\n                \"sentiment_label\": \"positive\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(days=1, hours=3)\n            },\n            {\n                \"message\": \"I'm feeling a bit lonely today. My usual walking group cancelled because of the weather.\",\n                \"response\": \"I'm sorry to hear you're feeling lonely today, Dorothy. Weather can really affect our plans, can't it? Would you like to talk about what you're feeling? Sometimes sharing helps. Maybe we could think of some indoor activities you enjoy?\",\n                \"sentiment_score\": -0.4,\n                \"sentiment_label\": \"negative\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(days=2, hours=5)\n            },\n            {\n                \"message\": \"I've been having some trouble remembering things lately. Yesterday I couldn't remember if I took my morning pills.\",\n                \"response\": \"Thank you for sharing that with me, Dorothy. Memory concerns can be worrying, and it's completely normal to feel concerned about this. For your medications, we can set up better tracking systems. Have you mentioned these memory concerns to your doctor?\",\n                \"sentiment_score\": -0.6,\n                \"sentiment_label\": \"negative\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(days=3, hours=2)\n            }\n        ]\n        \n        sample_conversations_user2 = [\n            {\n                \"message\": \"Hi Carely, I had a great day reading in the park. The weather was perfect.\",\n                \"response\": \"Hello Robert! That sounds like a lovely day. Reading in the park sounds so peaceful and enjoyable. What book were you reading? I'd love to hear about it.\",\n                \"sentiment_score\": 0.6,\n                \"sentiment_label\": \"positive\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(hours=4)\n            },\n            {\n                \"message\": \"I'm worried about my cholesterol levels. The doctor wants to see me again next month.\",\n                \"response\": \"I understand why you might be feeling worried about that, Robert. It's natural to have concerns about health check-ups. The good news is that you're taking your Atorvastatin regularly, which should help. How have you been feeling overall?\",\n                \"sentiment_score\": -0.3,\n                \"sentiment_label\": \"negative\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(days=1, hours=6)\n            },\n            {\n                \"message\": \"I played chess online with my old colleague today. I won two games!\",\n                \"response\": \"That's fantastic, Robert! Winning two chess games must feel great, especially against a good opponent. Chess is such a wonderful way to keep your mind sharp and stay connected with friends. Do you play regularly?\",\n                \"sentiment_score\": 0.7,\n                \"sentiment_label\": \"positive\",\n                \"conversation_type\": \"general\",\n                \"timestamp\": datetime.now() - timedelta(days=2, hours=3)\n            }\n        ]\n        \n        # Save conversations\n        for conv_data in sample_conversations_user1:\n            ConversationCRUD.save_conversation(\n                user_id=user1.id,\n                message=conv_data[\"message\"],\n                response=conv_data[\"response\"],\n                sentiment_score=conv_data[\"sentiment_score\"],\n                sentiment_label=conv_data[\"sentiment_label\"],\n                conversation_type=conv_data[\"conversation_type\"]\n            )\n        \n        for conv_data in sample_conversations_user2:\n            ConversationCRUD.save_conversation(\n                user_id=user2.id,\n                message=conv_data[\"message\"],\n                response=conv_data[\"response\"],\n                sentiment_score=conv_data[\"sentiment_score\"],\n                sentiment_label=conv_data[\"sentiment_label\"],\n                conversation_type=conv_data[\"conversation_type\"]\n            )\n        \n        print(f\"Created {len(sample_conversations_user1) + len(sample_conversations_user2)} sample conversations\")\n        \n        # Create sample medication logs (showing some adherence patterns)\n        # Dorothy's medication logs - good adherence with a few missed doses\n        for i in range(7):  # Last 7 days\n            day = datetime.now() - timedelta(days=i)\n            \n            # Lisinopril (morning)\n            morning_time = day.replace(hour=9, minute=0, second=0, microsecond=0)\n            status = \"taken\" if i not in [1, 4] else \"missed\"  # Missed on day 1 and 4\n            MedicationLogCRUD.log_medication_taken(\n                user_id=user1.id,\n                medication_id=med1.id,\n                scheduled_time=morning_time,\n                taken_time=morning_time + timedelta(minutes=15) if status == \"taken\" else None,\n                status=status\n            )\n            \n            # Metformin (morning and evening)\n            morning_metformin = day.replace(hour=8, minute=0, second=0, microsecond=0)\n            evening_metformin = day.replace(hour=20, minute=0, second=0, microsecond=0)\n            \n            MedicationLogCRUD.log_medication_taken(\n                user_id=user1.id,\n                medication_id=med2.id,\n                scheduled_time=morning_metformin,\n                taken_time=morning_metformin + timedelta(minutes=10) if i != 1 else None,\n                status=\"taken\" if i != 1 else \"missed\"\n            )\n            \n            MedicationLogCRUD.log_medication_taken(\n                user_id=user1.id,\n                medication_id=med2.id,\n                scheduled_time=evening_metformin,\n                taken_time=evening_metformin + timedelta(minutes=5) if i not in [1, 4] else None,\n                status=\"taken\" if i not in [1, 4] else \"missed\"\n            )\n            \n            # Vitamin D\n            vitamin_d_time = day.replace(hour=9, minute=5, second=0, microsecond=0)\n            MedicationLogCRUD.log_medication_taken(\n                user_id=user1.id,\n                medication_id=med3.id,\n                scheduled_time=vitamin_d_time,\n                taken_time=vitamin_d_time + timedelta(minutes=5),\n                status=\"taken\"  # Dorothy is consistent with vitamins\n            )\n        \n        # Robert's medication logs - very good adherence\n        for i in range(7):\n            day = datetime.now() - timedelta(days=i)\n            \n            # Atorvastatin (evening)\n            evening_time = day.replace(hour=21, minute=0, second=0, microsecond=0)\n            MedicationLogCRUD.log_medication_taken(\n                user_id=user2.id,\n                medication_id=med4.id,\n                scheduled_time=evening_time,\n                taken_time=evening_time + timedelta(minutes=10),\n                status=\"taken\"\n            )\n            \n            # Aspirin (morning)\n            morning_aspirin = day.replace(hour=9, minute=0, second=0, microsecond=0)\n            status = \"taken\" if i != 2 else \"missed\"  # Only missed once\n            MedicationLogCRUD.log_medication_taken(\n                user_id=user2.id,\n                medication_id=med5.id,\n                scheduled_time=morning_aspirin,\n                taken_time=morning_aspirin + timedelta(minutes=5) if status == \"taken\" else None,\n                status=status\n            )\n        \n        print(\"Created sample medication logs\")\n        \n        # Create some sample reminders\n        ReminderCRUD.create_reminder(\n            user_id=user1.id,\n            reminder_type=\"checkin\",\n            title=\"Good Morning Check-in\",\n            message=\"Good morning Dorothy! How are you feeling today? Did you sleep well?\",\n            scheduled_time=datetime.now() + timedelta(hours=1)\n        )\n        \n        ReminderCRUD.create_reminder(\n            user_id=user1.id,\n            reminder_type=\"medication\",\n            title=\"Evening Metformin Reminder\",\n            message=\"Hi Dorothy, it's time for your evening Metformin (500mg). Remember to take it with food!\",\n            scheduled_time=datetime.now() + timedelta(hours=8),\n            medication_id=med2.id\n        )\n        \n        ReminderCRUD.create_reminder(\n            user_id=user2.id,\n            reminder_type=\"medication\",\n            title=\"Evening Atorvastatin\",\n            message=\"Good evening Robert, time for your Atorvastatin (20mg). Remember to avoid grapefruit!\",\n            scheduled_time=datetime.now() + timedelta(hours=10),\n            medication_id=med4.id\n        )\n        \n        print(\"Created sample reminders\")\n        \n        # Create some sample caregiver alerts\n        CaregiverAlertCRUD.create_alert(\n            user_id=user1.id,\n            alert_type=\"mood_concern\",\n            title=\"Memory Concerns Expressed\",\n            description=\"Dorothy mentioned having trouble remembering things lately and specifically mentioned uncertainty about taking morning medications. She expressed concern about her memory in yesterday's conversation.\",\n            severity=\"medium\"\n        )\n        \n        CaregiverAlertCRUD.create_alert(\n            user_id=user1.id,\n            alert_type=\"medication_missed\",\n            title=\"Medication Adherence Pattern\",\n            description=\"Dorothy has missed several doses of Lisinopril and Metformin over the past week (adherence rate: 76%). Consider reviewing medication schedule or reminder system.\",\n            severity=\"medium\"\n        )\n        \n        CaregiverAlertCRUD.create_alert(\n            user_id=user2.id,\n            alert_type=\"health_concern\",\n            title=\"Health Anxiety\",\n            description=\"Robert expressed worry about upcoming cholesterol follow-up appointment. While taking medication regularly, he may benefit from reassurance about his health management.\",\n            severity=\"low\"\n        )\n        \n        print(\"Created sample caregiver alerts\")\n        \n        print(\"‚úÖ Sample data initialization complete!\")\n        print(f\"   - Users created: {user1.name}, {user2.name}\")\n        print(f\"   - Medications: 5 total\")\n        print(f\"   - Conversations: {len(sample_conversations_user1) + len(sample_conversations_user2)} total\")\n        print(f\"   - Medication logs: 7 days of sample data\")\n        print(f\"   - Reminders: 3 active\")\n        print(f\"   - Alerts: 3 for caregiver attention\")\n        \n    except Exception as e:\n        print(f\"Error initializing sample data: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    # Create tables first\n    create_tables()\n    # Initialize sample data\n    initialize_sample_data()\n","size_bytes":18507},"app/database/crud.py":{"content":"from sqlmodel import Session, select\nfrom datetime import datetime, timedelta\nfrom typing import List, Optional\nimport json\nfrom app.database.models import (\n    get_session, User, Medication, Conversation, Reminder, \n    MedicationLog, CaregiverAlert, CaregiverPatientAssignment, PersonalEvent\n)\n\nclass UserCRUD:\n    @staticmethod\n    def create_user(name: str, email: str = None, phone: str = None, \n                   preferences: dict = None, emergency_contact: str = None,\n                   user_type: str = \"patient\", password: str = None) -> User:\n        \"\"\"Create a new user\"\"\"\n        with get_session() as session:\n            preferences_json = json.dumps(preferences) if preferences else None\n            password_hash = None\n            if password:\n                import hashlib\n                password_hash = hashlib.sha256(password.encode()).hexdigest()\n            \n            user = User(\n                name=name,\n                email=email,\n                phone=phone,\n                preferences=preferences_json,\n                emergency_contact=emergency_contact,\n                user_type=user_type,\n                password_hash=password_hash\n            )\n            session.add(user)\n            session.commit()\n            session.refresh(user)\n            return user\n    \n    @staticmethod\n    def get_user(user_id: int) -> Optional[User]:\n        \"\"\"Get user by ID\"\"\"\n        with get_session() as session:\n            return session.get(User, user_id)\n    \n    @staticmethod\n    def get_all_users() -> List[User]:\n        \"\"\"Get all users\"\"\"\n        with get_session() as session:\n            return session.exec(select(User)).all()\n\nclass MedicationCRUD:\n    @staticmethod\n    def create_medication(user_id: int, name: str, dosage: str, frequency: str,\n                         schedule_times: List[str], instructions: str = None) -> Medication:\n        \"\"\"Create a new medication\"\"\"\n        with get_session() as session:\n            medication = Medication(\n                user_id=user_id,\n                name=name,\n                dosage=dosage,\n                frequency=frequency,\n                schedule_times=json.dumps(schedule_times),\n                instructions=instructions\n            )\n            session.add(medication)\n            session.commit()\n            session.refresh(medication)\n            return medication\n    \n    @staticmethod\n    def get_user_medications(user_id: int, active_only: bool = True) -> List[Medication]:\n        \"\"\"Get all medications for a user\"\"\"\n        with get_session() as session:\n            query = select(Medication).where(Medication.user_id == user_id)\n            if active_only:\n                query = query.where(Medication.active == True)\n            return session.exec(query).all()\n    \n    @staticmethod\n    def update_medication(medication_id: int, **kwargs) -> Optional[Medication]:\n        \"\"\"Update medication\"\"\"\n        with get_session() as session:\n            medication = session.get(Medication, medication_id)\n            if medication:\n                for key, value in kwargs.items():\n                    setattr(medication, key, value)\n                session.add(medication)\n                session.commit()\n                session.refresh(medication)\n            return medication\n\nclass ConversationCRUD:\n    @staticmethod\n    def save_conversation(user_id: int, message: str, response: str,\n                         sentiment_score: float = None, sentiment_label: str = None,\n                         conversation_type: str = \"general\") -> Conversation:\n        \"\"\"Save a conversation\"\"\"\n        with get_session() as session:\n            conversation = Conversation(\n                user_id=user_id,\n                message=message,\n                response=response,\n                sentiment_score=sentiment_score,\n                sentiment_label=sentiment_label,\n                conversation_type=conversation_type\n            )\n            session.add(conversation)\n            session.commit()\n            session.refresh(conversation)\n            return conversation\n    \n    @staticmethod\n    def get_user_conversations(user_id: int, limit: int = 50) -> List[Conversation]:\n        \"\"\"Get recent conversations for a user\"\"\"\n        with get_session() as session:\n            query = select(Conversation).where(\n                Conversation.user_id == user_id\n            ).order_by(Conversation.timestamp.desc()).limit(limit)\n            return session.exec(query).all()\n    \n    @staticmethod\n    def get_recent_sentiment_data(user_id: int, days: int = 7) -> List[Conversation]:\n        \"\"\"Get recent conversations with sentiment data\"\"\"\n        with get_session() as session:\n            cutoff_date = datetime.now() - timedelta(days=days)\n            query = select(Conversation).where(\n                Conversation.user_id == user_id,\n                Conversation.timestamp >= cutoff_date,\n                Conversation.sentiment_score.isnot(None)\n            ).order_by(Conversation.timestamp.desc())\n            return session.exec(query).all()\n\nclass ReminderCRUD:\n    @staticmethod\n    def create_reminder(user_id: int, reminder_type: str, title: str, message: str,\n                       scheduled_time: datetime, medication_id: int = None) -> Reminder:\n        \"\"\"Create a new reminder\"\"\"\n        with get_session() as session:\n            reminder = Reminder(\n                user_id=user_id,\n                reminder_type=reminder_type,\n                title=title,\n                message=message,\n                scheduled_time=scheduled_time,\n                medication_id=medication_id\n            )\n            session.add(reminder)\n            session.commit()\n            session.refresh(reminder)\n            return reminder\n    \n    @staticmethod\n    def get_pending_reminders(user_id: int = None) -> List[Reminder]:\n        \"\"\"Get pending reminders\"\"\"\n        with get_session() as session:\n            query = select(Reminder).where(\n                Reminder.completed == False,\n                Reminder.scheduled_time <= datetime.now()\n            )\n            if user_id:\n                query = query.where(Reminder.user_id == user_id)\n            return session.exec(query).all()\n    \n    @staticmethod\n    def complete_reminder(reminder_id: int) -> Optional[Reminder]:\n        \"\"\"Mark reminder as completed\"\"\"\n        with get_session() as session:\n            reminder = session.get(Reminder, reminder_id)\n            if reminder:\n                reminder.completed = True\n                reminder.completed_at = datetime.now()\n                session.add(reminder)\n                session.commit()\n                session.refresh(reminder)\n            return reminder\n\nclass MedicationLogCRUD:\n    @staticmethod\n    def log_medication_taken(user_id: int, medication_id: int, scheduled_time: datetime,\n                           taken_time: datetime = None, status: str = \"taken\",\n                           notes: str = None) -> MedicationLog:\n        \"\"\"Log medication intake\"\"\"\n        with get_session() as session:\n            log = MedicationLog(\n                user_id=user_id,\n                medication_id=medication_id,\n                scheduled_time=scheduled_time,\n                taken_time=taken_time or datetime.now(),\n                status=status,\n                notes=notes\n            )\n            session.add(log)\n            session.commit()\n            session.refresh(log)\n            return log\n    \n    @staticmethod\n    def get_medication_adherence(user_id: int, days: int = 7) -> dict:\n        \"\"\"Get medication adherence statistics\"\"\"\n        with get_session() as session:\n            cutoff_date = datetime.now() - timedelta(days=days)\n            query = select(MedicationLog).where(\n                MedicationLog.user_id == user_id,\n                MedicationLog.scheduled_time >= cutoff_date\n            )\n            logs = session.exec(query).all()\n            \n            total = len(logs)\n            taken = len([log for log in logs if log.status == \"taken\"])\n            missed = len([log for log in logs if log.status == \"missed\"])\n            \n            return {\n                \"total\": total,\n                \"taken\": taken,\n                \"missed\": missed,\n                \"adherence_rate\": (taken / total * 100) if total > 0 else 0,\n                \"logs\": logs\n            }\n\nclass CaregiverAlertCRUD:\n    @staticmethod\n    def create_alert(user_id: int, alert_type: str, title: str, description: str,\n                    severity: str = \"medium\") -> CaregiverAlert:\n        \"\"\"Create a caregiver alert\"\"\"\n        with get_session() as session:\n            alert = CaregiverAlert(\n                user_id=user_id,\n                alert_type=alert_type,\n                title=title,\n                description=description,\n                severity=severity\n            )\n            session.add(alert)\n            session.commit()\n            session.refresh(alert)\n            return alert\n    \n    @staticmethod\n    def get_unresolved_alerts(user_id: int = None) -> List[CaregiverAlert]:\n        \"\"\"Get unresolved alerts\"\"\"\n        with get_session() as session:\n            query = select(CaregiverAlert).where(CaregiverAlert.resolved == False)\n            if user_id:\n                query = query.where(CaregiverAlert.user_id == user_id)\n            query = query.order_by(CaregiverAlert.created_at.desc())\n            return session.exec(query).all()\n    \n    @staticmethod\n    def resolve_alert(alert_id: int) -> Optional[CaregiverAlert]:\n        \"\"\"Resolve an alert\"\"\"\n        with get_session() as session:\n            alert = session.get(CaregiverAlert, alert_id)\n            if alert:\n                alert.resolved = True\n                alert.resolved_at = datetime.now()\n                session.add(alert)\n                session.commit()\n                session.refresh(alert)\n            return alert\n\nclass CaregiverPatientCRUD:\n    @staticmethod\n    def assign_patient(caregiver_id: int, patient_id: int, relationship: str = None, \n                      notification_preferences: dict = None) -> CaregiverPatientAssignment:\n        \"\"\"Assign a patient to a caregiver\"\"\"\n        with get_session() as session:\n            assignment = CaregiverPatientAssignment(\n                caregiver_id=caregiver_id,\n                patient_id=patient_id,\n                relationship=relationship,\n                notification_preferences=json.dumps(notification_preferences) if notification_preferences else None\n            )\n            session.add(assignment)\n            session.commit()\n            session.refresh(assignment)\n            return assignment\n    \n    @staticmethod\n    def get_caregiver_patients(caregiver_id: int) -> List[User]:\n        \"\"\"Get all patients assigned to a caregiver\"\"\"\n        with get_session() as session:\n            query = select(CaregiverPatientAssignment).where(\n                CaregiverPatientAssignment.caregiver_id == caregiver_id\n            )\n            assignments = session.exec(query).all()\n            \n            patients = []\n            for assignment in assignments:\n                patient = session.get(User, assignment.patient_id)\n                if patient:\n                    patients.append(patient)\n            return patients\n    \n    @staticmethod\n    def get_patient_caregivers(patient_id: int) -> List[User]:\n        \"\"\"Get all caregivers assigned to a patient\"\"\"\n        with get_session() as session:\n            query = select(CaregiverPatientAssignment).where(\n                CaregiverPatientAssignment.patient_id == patient_id\n            )\n            assignments = session.exec(query).all()\n            \n            caregivers = []\n            for assignment in assignments:\n                caregiver = session.get(User, assignment.caregiver_id)\n                if caregiver:\n                    caregivers.append(caregiver)\n            return caregivers\n    \n    @staticmethod\n    def remove_assignment(caregiver_id: int, patient_id: int) -> bool:\n        \"\"\"Remove patient assignment from caregiver\"\"\"\n        with get_session() as session:\n            query = select(CaregiverPatientAssignment).where(\n                CaregiverPatientAssignment.caregiver_id == caregiver_id,\n                CaregiverPatientAssignment.patient_id == patient_id\n            )\n            assignment = session.exec(query).first()\n            if assignment:\n                session.delete(assignment)\n                session.commit()\n                return True\n            return False\n\nclass PersonalEventCRUD:\n    @staticmethod\n    def create_event(user_id: int, event_type: str, title: str, description: str = None,\n                    event_date: datetime = None, recurring: bool = False, \n                    importance: str = \"medium\") -> PersonalEvent:\n        \"\"\"Create a personal event for memory tracking\"\"\"\n        with get_session() as session:\n            event = PersonalEvent(\n                user_id=user_id,\n                event_type=event_type,\n                title=title,\n                description=description,\n                event_date=event_date,\n                recurring=recurring,\n                importance=importance\n            )\n            session.add(event)\n            session.commit()\n            session.refresh(event)\n            return event\n    \n    @staticmethod\n    def get_user_events(user_id: int, limit: int = 50) -> List[PersonalEvent]:\n        \"\"\"Get personal events for a user\"\"\"\n        with get_session() as session:\n            query = select(PersonalEvent).where(\n                PersonalEvent.user_id == user_id\n            ).order_by(PersonalEvent.created_at.desc()).limit(limit)\n            return session.exec(query).all()\n    \n    @staticmethod\n    def get_upcoming_events(user_id: int, days: int = 30) -> List[PersonalEvent]:\n        \"\"\"Get upcoming events in the next N days\"\"\"\n        with get_session() as session:\n            future_date = datetime.now() + timedelta(days=days)\n            query = select(PersonalEvent).where(\n                PersonalEvent.user_id == user_id,\n                PersonalEvent.event_date.isnot(None),\n                PersonalEvent.event_date <= future_date,\n                PersonalEvent.event_date >= datetime.now()\n            ).order_by(PersonalEvent.event_date)\n            return session.exec(query).all()\n    \n    @staticmethod\n    def delete_event(event_id: int) -> bool:\n        \"\"\"Delete a personal event\"\"\"\n        with get_session() as session:\n            event = session.get(PersonalEvent, event_id)\n            if event:\n                session.delete(event)\n                session.commit()\n                return True\n            return False\n","size_bytes":14739},"utils/sentiment_analysis.py":{"content":"import os\nimport json\nfrom openai import OpenAI\nfrom typing import Dict, Any\n\n# the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\nclass SentimentAnalyzer:\n    def __init__(self):\n        self.client = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n        self.model = \"gpt-5\"  # Using latest model\n    \n    def analyze(self, text: str) -> Dict[str, Any]:\n        \"\"\"\n        Analyze sentiment of text using OpenAI GPT-5\n        Returns: {\n            \"score\": float (-1 to 1),\n            \"label\": str (\"positive\", \"negative\", \"neutral\"),\n            \"confidence\": float (0 to 1),\n            \"emotions\": list of detected emotions\n        }\n        \"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert sentiment analyzer specializing in elderly care conversations. \n                        Analyze the sentiment of the given text and provide:\n                        1. A sentiment score from -1 (very negative) to 1 (very positive)\n                        2. A label: \"positive\", \"negative\", or \"neutral\"\n                        3. A confidence score from 0 to 1\n                        4. A list of detected emotions (e.g., joy, sadness, anxiety, contentment, worry, etc.)\n                        \n                        Be especially sensitive to:\n                        - Signs of pain, discomfort, or distress\n                        - Loneliness or isolation\n                        - Confusion or memory concerns\n                        - Medication-related anxiety\n                        - Family or social connections\n                        \n                        Respond with JSON only in this format:\n                        {\n                            \"score\": -0.5,\n                            \"label\": \"negative\",\n                            \"confidence\": 0.8,\n                            \"emotions\": [\"worry\", \"sadness\"]\n                        }\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": f\"Analyze the sentiment of this text: \\\"{text}\\\"\"\n                    }\n                ],\n                response_format={\"type\": \"json_object\"},\n                max_completion_tokens=200\n            )\n            \n            result = json.loads(response.choices[0].message.content)\n            \n            # Validate and clean the response\n            return {\n                \"score\": max(-1, min(1, float(result.get(\"score\", 0)))),\n                \"label\": result.get(\"label\", \"neutral\"),\n                \"confidence\": max(0, min(1, float(result.get(\"confidence\", 0.5)))),\n                \"emotions\": result.get(\"emotions\", [])\n            }\n            \n        except Exception as e:\n            # Fallback to simple rule-based analysis\n            return self._fallback_analysis(text)\n    \n    def _fallback_analysis(self, text: str) -> Dict[str, Any]:\n        \"\"\"\n        Simple rule-based sentiment analysis as fallback\n        \"\"\"\n        text_lower = text.lower()\n        \n        # Define word lists\n        positive_words = [\n            \"good\", \"great\", \"happy\", \"wonderful\", \"excellent\", \"love\", \"enjoy\",\n            \"better\", \"fine\", \"well\", \"nice\", \"pleasant\", \"comfortable\", \"peaceful\"\n        ]\n        \n        negative_words = [\n            \"bad\", \"terrible\", \"awful\", \"hate\", \"horrible\", \"pain\", \"hurt\", \"sad\",\n            \"worried\", \"anxious\", \"confused\", \"lost\", \"dizzy\", \"sick\", \"tired\",\n            \"lonely\", \"scared\", \"frightened\", \"depressed\", \"upset\"\n        ]\n        \n        concern_words = [\n            \"pain\", \"hurt\", \"dizzy\", \"fall\", \"emergency\", \"help\", \"confused\",\n            \"memory\", \"forgot\", \"lost\", \"scared\", \"can't\", \"unable\", \"difficult\"\n        ]\n        \n        # Count words\n        positive_count = sum(1 for word in positive_words if word in text_lower)\n        negative_count = sum(1 for word in negative_words if word in text_lower)\n        concern_count = sum(1 for word in concern_words if word in text_lower)\n        \n        # Calculate score\n        total_words = len(text_lower.split())\n        if total_words == 0:\n            return {\"score\": 0, \"label\": \"neutral\", \"confidence\": 0.5, \"emotions\": []}\n        \n        # Weight concerns more heavily\n        score = (positive_count - negative_count - (concern_count * 1.5)) / total_words\n        score = max(-1, min(1, score))\n        \n        # Determine label\n        if score > 0.1:\n            label = \"positive\"\n        elif score < -0.1:\n            label = \"negative\"\n        else:\n            label = \"neutral\"\n        \n        # Basic emotion detection\n        emotions = []\n        if concern_count > 0:\n            emotions.append(\"concern\")\n        if any(word in text_lower for word in [\"pain\", \"hurt\", \"sick\"]):\n            emotions.append(\"discomfort\")\n        if any(word in text_lower for word in [\"lonely\", \"alone\", \"miss\"]):\n            emotions.append(\"loneliness\")\n        if any(word in text_lower for word in [\"happy\", \"good\", \"great\"]):\n            emotions.append(\"contentment\")\n        if any(word in text_lower for word in [\"worried\", \"anxious\", \"scared\"]):\n            emotions.append(\"anxiety\")\n        \n        return {\n            \"score\": score,\n            \"label\": label,\n            \"confidence\": 0.6,  # Lower confidence for rule-based\n            \"emotions\": emotions\n        }\n\n# Global instance for easy access\n_analyzer = None\n\ndef get_analyzer():\n    \"\"\"Get singleton sentiment analyzer instance\"\"\"\n    global _analyzer\n    if _analyzer is None:\n        _analyzer = SentimentAnalyzer()\n    return _analyzer\n\ndef analyze_sentiment(text: str) -> Dict[str, Any]:\n    \"\"\"\n    Convenience function to analyze sentiment\n    \"\"\"\n    analyzer = get_analyzer()\n    return analyzer.analyze(text)\n\n# Additional utility functions\ndef get_sentiment_emoji(score: float) -> str:\n    \"\"\"Convert sentiment score to emoji\"\"\"\n    if score > 0.5:\n        return \"üòä\"\n    elif score > 0.2:\n        return \"üôÇ\"\n    elif score > -0.2:\n        return \"üòê\"\n    elif score > -0.5:\n        return \"üòü\"\n    else:\n        return \"üò¢\"\n\ndef get_sentiment_color(score: float) -> str:\n    \"\"\"Convert sentiment score to color (for UI)\"\"\"\n    if score > 0.3:\n        return \"green\"\n    elif score > -0.3:\n        return \"yellow\"\n    else:\n        return \"red\"\n\ndef classify_concern_level(emotions: list, score: float) -> str:\n    \"\"\"Classify the level of concern based on emotions and score\"\"\"\n    high_concern_emotions = [\"anxiety\", \"fear\", \"distress\", \"confusion\"]\n    medium_concern_emotions = [\"worry\", \"sadness\", \"discomfort\", \"loneliness\"]\n    \n    if any(emotion in high_concern_emotions for emotion in emotions) or score < -0.7:\n        return \"high\"\n    elif any(emotion in medium_concern_emotions for emotion in emotions) or score < -0.3:\n        return \"medium\"\n    else:\n        return \"low\"\n","size_bytes":7111},"app/scheduling/reminder_scheduler.py":{"content":"from apscheduler.schedulers.background import BackgroundScheduler\nfrom apscheduler.triggers.cron import CronTrigger\nfrom apscheduler.triggers.date import DateTrigger\nfrom datetime import datetime, timedelta, time\nimport json\nimport logging\nfrom typing import List, Dict, Any\n\nfrom app.database.crud import (\n    ReminderCRUD, MedicationCRUD, MedicationLogCRUD, \n    CaregiverAlertCRUD, UserCRUD\n)\nfrom app.agents.companion_agent import CompanionAgent\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass ReminderScheduler:\n    def __init__(self):\n        self.scheduler = BackgroundScheduler()\n        self.companion_agent = CompanionAgent()\n        self.is_running = False\n    \n    def start(self):\n        \"\"\"Start the scheduler with all recurring jobs\"\"\"\n        if self.is_running:\n            return\n        \n        try:\n            # Schedule daily check-ins\n            self.schedule_daily_checkins()\n            \n            # Schedule medication reminders\n            self.schedule_medication_reminders()\n            \n            # Schedule weekly reports\n            self.schedule_weekly_reports()\n            \n            # Schedule adherence monitoring\n            self.schedule_adherence_monitoring()\n            \n            self.scheduler.start()\n            self.is_running = True\n            logger.info(\"Reminder scheduler started successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to start scheduler: {e}\")\n    \n    def stop(self):\n        \"\"\"Stop the scheduler\"\"\"\n        if self.scheduler.running:\n            self.scheduler.shutdown()\n            self.is_running = False\n            logger.info(\"Reminder scheduler stopped\")\n    \n    def schedule_daily_checkins(self):\n        \"\"\"Schedule daily check-ins at fixed times\"\"\"\n        # Morning check-in at 9:00 AM\n        self.scheduler.add_job(\n            func=self.morning_checkin,\n            trigger=CronTrigger(hour=9, minute=0),\n            id='morning_checkin',\n            name='Morning Check-in',\n            replace_existing=True\n        )\n        \n        # Afternoon check-in at 2:00 PM\n        self.scheduler.add_job(\n            func=self.afternoon_checkin,\n            trigger=CronTrigger(hour=14, minute=0),\n            id='afternoon_checkin',\n            name='Afternoon Check-in',\n            replace_existing=True\n        )\n        \n        # Evening check-in at 7:00 PM\n        self.scheduler.add_job(\n            func=self.evening_checkin,\n            trigger=CronTrigger(hour=19, minute=0),\n            id='evening_checkin',\n            name='Evening Check-in',\n            replace_existing=True\n        )\n        \n        logger.info(\"Daily check-ins scheduled\")\n    \n    def schedule_medication_reminders(self):\n        \"\"\"Schedule medication reminders for all users\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            \n            for user in users:\n                medications = MedicationCRUD.get_user_medications(user.id)\n                \n                for medication in medications:\n                    if not medication.active or not medication.schedule_times:\n                        continue\n                    \n                    try:\n                        schedule_times = json.loads(medication.schedule_times)\n                        \n                        for time_str in schedule_times:\n                            # Parse time string (expected format: \"HH:MM\")\n                            hour, minute = map(int, time_str.split(':'))\n                            \n                            job_id = f'med_reminder_{medication.id}_{time_str.replace(\":\", \"\")}'\n                            \n                            self.scheduler.add_job(\n                                func=self.medication_reminder,\n                                trigger=CronTrigger(hour=hour, minute=minute),\n                                args=[user.id, medication.id],\n                                id=job_id,\n                                name=f'Medication reminder for {medication.name}',\n                                replace_existing=True\n                            )\n                            \n                    except (json.JSONDecodeError, ValueError) as e:\n                        logger.error(f\"Invalid schedule format for medication {medication.id}: {e}\")\n            \n            logger.info(\"Medication reminders scheduled for all users\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to schedule medication reminders: {e}\")\n    \n    def schedule_weekly_reports(self):\n        \"\"\"Schedule weekly summary reports\"\"\"\n        self.scheduler.add_job(\n            func=self.generate_weekly_report,\n            trigger=CronTrigger(day_of_week=0, hour=8, minute=0),  # Monday at 8 AM\n            id='weekly_report',\n            name='Weekly Summary Report',\n            replace_existing=True\n        )\n        \n        logger.info(\"Weekly reports scheduled\")\n    \n    def schedule_adherence_monitoring(self):\n        \"\"\"Schedule medication adherence monitoring\"\"\"\n        # Check for missed medications every 2 hours\n        self.scheduler.add_job(\n            func=self.check_missed_medications,\n            trigger=CronTrigger(minute=0, second=0),  # Every hour\n            id='adherence_monitoring',\n            name='Medication Adherence Monitoring',\n            replace_existing=True\n        )\n        \n        logger.info(\"Adherence monitoring scheduled\")\n    \n    def morning_checkin(self):\n        \"\"\"Perform morning check-in for all users\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            \n            for user in users:\n                # Create a reminder for morning check-in\n                checkin = self.companion_agent.conduct_daily_checkin(user.id, \"morning\")\n                \n                ReminderCRUD.create_reminder(\n                    user_id=user.id,\n                    reminder_type=\"checkin\",\n                    title=\"Morning Check-in\",\n                    message=checkin[\"prompt\"],\n                    scheduled_time=datetime.now()\n                )\n            \n            logger.info(f\"Morning check-in completed for {len(users)} users\")\n            \n        except Exception as e:\n            logger.error(f\"Morning check-in failed: {e}\")\n    \n    def afternoon_checkin(self):\n        \"\"\"Perform afternoon check-in for all users\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            \n            for user in users:\n                checkin = self.companion_agent.conduct_daily_checkin(user.id, \"afternoon\")\n                \n                ReminderCRUD.create_reminder(\n                    user_id=user.id,\n                    reminder_type=\"checkin\",\n                    title=\"Afternoon Check-in\",\n                    message=checkin[\"prompt\"],\n                    scheduled_time=datetime.now()\n                )\n            \n            logger.info(f\"Afternoon check-in completed for {len(users)} users\")\n            \n        except Exception as e:\n            logger.error(f\"Afternoon check-in failed: {e}\")\n    \n    def evening_checkin(self):\n        \"\"\"Perform evening check-in for all users\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            \n            for user in users:\n                checkin = self.companion_agent.conduct_daily_checkin(user.id, \"evening\")\n                \n                ReminderCRUD.create_reminder(\n                    user_id=user.id,\n                    reminder_type=\"checkin\",\n                    title=\"Evening Check-in\",\n                    message=checkin[\"prompt\"],\n                    scheduled_time=datetime.now()\n                )\n            \n            logger.info(f\"Evening check-in completed for {len(users)} users\")\n            \n        except Exception as e:\n            logger.error(f\"Evening check-in failed: {e}\")\n    \n    def medication_reminder(self, user_id: int, medication_id: int):\n        \"\"\"Send medication reminder to specific user\"\"\"\n        try:\n            medication = MedicationCRUD.get_user_medications(user_id)\n            medication = next((med for med in medication if med.id == medication_id), None)\n            \n            if not medication:\n                logger.error(f\"Medication {medication_id} not found for user {user_id}\")\n                return\n            \n            user = UserCRUD.get_user(user_id)\n            user_name = user.name if user else \"there\"\n            \n            reminder_message = f\"Hi {user_name}, it's time to take your {medication.name} ({medication.dosage}). {medication.instructions or ''}\"\n            \n            ReminderCRUD.create_reminder(\n                user_id=user_id,\n                reminder_type=\"medication\",\n                title=f\"Time for {medication.name}\",\n                message=reminder_message,\n                scheduled_time=datetime.now(),\n                medication_id=medication_id\n            )\n            \n            logger.info(f\"Medication reminder sent for {medication.name} to user {user_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to send medication reminder: {e}\")\n    \n    def check_missed_medications(self):\n        \"\"\"Check for missed medications and create alerts\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            current_time = datetime.now()\n            \n            for user in users:\n                # Get medication adherence for last 24 hours\n                adherence = MedicationLogCRUD.get_medication_adherence(user.id, days=1)\n                \n                # Check for missed medications in the last 2 hours\n                recent_missed = 0\n                for log in adherence.get(\"logs\", []):\n                    if (log.status == \"missed\" and \n                        current_time - log.scheduled_time < timedelta(hours=2)):\n                        recent_missed += 1\n                \n                # Alert if adherence is below 80% or recent missed doses\n                if adherence.get(\"adherence_rate\", 100) < 80 or recent_missed > 0:\n                    alert_description = f\"Medication adherence concern: {adherence.get('adherence_rate', 0):.1f}% adherence rate\"\n                    if recent_missed > 0:\n                        alert_description += f\", {recent_missed} missed doses in last 2 hours\"\n                    \n                    CaregiverAlertCRUD.create_alert(\n                        user_id=user.id,\n                        alert_type=\"medication_missed\",\n                        title=\"Medication Adherence Alert\",\n                        description=alert_description,\n                        severity=\"high\" if recent_missed > 1 else \"medium\"\n                    )\n            \n            logger.info(\"Medication adherence monitoring completed\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to check missed medications: {e}\")\n    \n    def generate_weekly_report(self):\n        \"\"\"Generate weekly summary reports for caregivers\"\"\"\n        try:\n            users = UserCRUD.get_all_users()\n            \n            for user in users:\n                # Get adherence data\n                adherence = MedicationLogCRUD.get_medication_adherence(user.id, days=7)\n                \n                # Get mood data\n                from app.database.crud import ConversationCRUD\n                conversations = ConversationCRUD.get_recent_sentiment_data(user.id, days=7)\n                \n                mood_scores = [c.sentiment_score for c in conversations if c.sentiment_score is not None]\n                avg_mood = sum(mood_scores) / len(mood_scores) if mood_scores else 0\n                \n                report = f\"\"\"Weekly Report for {user.name}:\n                \nMedication Adherence:\n- Total doses: {adherence.get('total', 0)}\n- Doses taken: {adherence.get('taken', 0)}\n- Adherence rate: {adherence.get('adherence_rate', 0):.1f}%\n\nMood & Wellbeing:\n- Average mood: {avg_mood:.2f} (scale: -1 to 1)\n- Total conversations: {len(conversations)}\n- Mood trend: {'Positive' if avg_mood > 0.2 else 'Neutral' if avg_mood > -0.2 else 'Concerning'}\n\nRecommendations:\n{self._generate_recommendations(user.id, adherence, avg_mood)}\n\"\"\"\n                \n                # Create alert with weekly report\n                CaregiverAlertCRUD.create_alert(\n                    user_id=user.id,\n                    alert_type=\"weekly_report\",\n                    title=f\"Weekly Report - {user.name}\",\n                    description=report,\n                    severity=\"low\"\n                )\n            \n            logger.info(f\"Weekly reports generated for {len(users)} users\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate weekly reports: {e}\")\n    \n    def _generate_recommendations(self, user_id: int, adherence: Dict, avg_mood: float) -> str:\n        \"\"\"Generate personalized recommendations based on data\"\"\"\n        recommendations = []\n        \n        if adherence.get(\"adherence_rate\", 100) < 90:\n            recommendations.append(\"- Consider medication reminder system improvements\")\n        \n        if avg_mood < -0.3:\n            recommendations.append(\"- Monitor mood closely, consider professional consultation\")\n        \n        if not recommendations:\n            recommendations.append(\"- Continue current care routine, all metrics look good\")\n        \n        return \"\\n\".join(recommendations)\n    \n    def add_custom_reminder(self, user_id: int, title: str, message: str, \n                          scheduled_time: datetime):\n        \"\"\"Add a custom one-time reminder\"\"\"\n        try:\n            # Create database entry\n            ReminderCRUD.create_reminder(\n                user_id=user_id,\n                reminder_type=\"custom\",\n                title=title,\n                message=message,\n                scheduled_time=scheduled_time\n            )\n            \n            # Schedule the reminder\n            job_id = f\"custom_reminder_{user_id}_{int(scheduled_time.timestamp())}\"\n            \n            self.scheduler.add_job(\n                func=self._send_custom_reminder,\n                trigger=DateTrigger(run_date=scheduled_time),\n                args=[user_id, title, message],\n                id=job_id,\n                name=f\"Custom reminder: {title}\",\n                replace_existing=True\n            )\n            \n            logger.info(f\"Custom reminder scheduled for user {user_id} at {scheduled_time}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to add custom reminder: {e}\")\n    \n    def _send_custom_reminder(self, user_id: int, title: str, message: str):\n        \"\"\"Send a custom reminder\"\"\"\n        try:\n            # This would typically send a notification\n            # For now, we'll just log it\n            logger.info(f\"Custom reminder for user {user_id}: {title} - {message}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to send custom reminder: {e}\")\n","size_bytes":15058},"frontend/caregiver_portal.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nfrom typing import List\n\nfrom app.database.crud import (\n    UserCRUD, CaregiverPatientCRUD, CaregiverAlertCRUD,\n    MedicationLogCRUD, ConversationCRUD\n)\nfrom app.auth.auth_utils import authenticate_user\nfrom utils.sentiment_analysis import get_sentiment_emoji, get_sentiment_color\n\ndef show_caregiver_login():\n    \"\"\"Show caregiver login page\"\"\"\n    st.title(\"üè• Caregiver Portal - Login\")\n    \n    with st.form(\"login_form\"):\n        email = st.text_input(\"Email\")\n        password = st.text_input(\"Password\", type=\"password\")\n        submit = st.form_submit_button(\"Login\")\n        \n        if submit:\n            user = authenticate_user(email, password)\n            if user and user.user_type in [\"caregiver\", \"admin\"]:\n                st.session_state.caregiver_id = user.id\n                st.session_state.caregiver_name = user.name\n                st.session_state.caregiver_type = user.user_type\n                st.success(f\"Welcome back, {user.name}!\")\n                st.rerun()\n            else:\n                st.error(\"Invalid credentials or insufficient permissions\")\n\ndef show_caregiver_dashboard():\n    \"\"\"Show caregiver dashboard\"\"\"\n    caregiver_id = st.session_state.get(\"caregiver_id\")\n    \n    if not caregiver_id:\n        show_caregiver_login()\n        return\n    \n    st.title(f\"üë®‚Äç‚öïÔ∏è Caregiver Portal - {st.session_state.get('caregiver_name')}\")\n    \n    # Logout button\n    col1, col2, col3 = st.columns([6, 1, 1])\n    with col3:\n        if st.button(\"Logout\"):\n            del st.session_state.caregiver_id\n            del st.session_state.caregiver_name\n            del st.session_state.caregiver_type\n            st.rerun()\n    \n    # Get assigned patients\n    patients = CaregiverPatientCRUD.get_caregiver_patients(caregiver_id)\n    \n    if not patients:\n        st.info(\"No patients assigned yet. Contact your administrator to assign patients.\")\n        return\n    \n    # Patient selector\n    patient_options = {f\"{p.name} (ID: {p.id})\": p.id for p in patients}\n    selected_patient_key = st.selectbox(\"Select Patient:\", list(patient_options.keys()))\n    selected_patient_id = patient_options[selected_patient_key]\n    \n    # Tabs for different views\n    tab1, tab2, tab3, tab4 = st.tabs([\n        \"üìä Overview\", \n        \"üö® Alerts\", \n        \"üíä Medications\",\n        \"üí¨ Conversations\"\n    ])\n    \n    with tab1:\n        show_patient_overview(selected_patient_id)\n    \n    with tab2:\n        show_patient_alerts(selected_patient_id)\n    \n    with tab3:\n        show_patient_medications(selected_patient_id)\n    \n    with tab4:\n        show_patient_conversations(selected_patient_id)\n\ndef show_patient_overview(patient_id: int):\n    \"\"\"Show patient overview for caregiver\"\"\"\n    patient = UserCRUD.get_user(patient_id)\n    \n    st.subheader(f\"Overview for {patient.name}\")\n    \n    # Key metrics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        adherence = MedicationLogCRUD.get_medication_adherence(patient_id, days=7)\n        st.metric(\"7-Day Adherence\", f\"{adherence.get('adherence_rate', 0):.0f}%\")\n    \n    with col2:\n        conversations = ConversationCRUD.get_recent_sentiment_data(patient_id, days=7)\n        if conversations:\n            avg_mood = sum(c.sentiment_score for c in conversations if c.sentiment_score) / len([c for c in conversations if c.sentiment_score])\n            mood_emoji = get_sentiment_emoji(avg_mood)\n            st.metric(\"Avg Mood (7d)\", f\"{mood_emoji} {avg_mood:.2f}\")\n        else:\n            st.metric(\"Avg Mood (7d)\", \"No data\")\n    \n    with col3:\n        alerts = CaregiverAlertCRUD.get_unresolved_alerts(patient_id)\n        high_priority = len([a for a in alerts if a.severity == \"high\"])\n        st.metric(\"Active Alerts\", len(alerts), delta=f\"{high_priority} high priority\" if high_priority > 0 else None)\n    \n    with col4:\n        missed_meds = adherence.get(\"missed\", 0)\n        st.metric(\"Missed Doses (7d)\", missed_meds, delta=f\"-{missed_meds}\" if missed_meds > 0 else None)\n    \n    st.divider()\n    \n    # Charts\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Medication Adherence Trend\")\n        if adherence.get(\"logs\"):\n            df = pd.DataFrame([\n                {\n                    \"date\": log.scheduled_time.date(),\n                    \"status\": \"Taken\" if log.status == \"taken\" else \"Missed\"\n                }\n                for log in adherence[\"logs\"]\n            ])\n            \n            daily_adherence = df.groupby(\"date\").apply(\n                lambda x: (x[\"status\"] == \"Taken\").sum() / len(x) * 100\n            ).reset_index(name=\"adherence_rate\")\n            daily_adherence[\"date\"] = pd.to_datetime(daily_adherence[\"date\"])\n            \n            fig = px.line(\n                daily_adherence, \n                x=\"date\", \n                y=\"adherence_rate\",\n                range_y=[0, 100]\n            )\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"orange\")\n            st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No medication data available\")\n    \n    with col2:\n        st.subheader(\"Mood Trend\")\n        if conversations:\n            df_mood = pd.DataFrame([\n                {\n                    \"date\": conv.timestamp.date(),\n                    \"sentiment_score\": conv.sentiment_score\n                }\n                for conv in conversations\n                if conv.sentiment_score is not None\n            ])\n            \n            daily_mood = df_mood.groupby(\"date\")[\"sentiment_score\"].mean().reset_index()\n            daily_mood[\"date\"] = pd.to_datetime(daily_mood[\"date\"])\n            \n            fig = px.line(\n                daily_mood, \n                x=\"date\", \n                y=\"sentiment_score\",\n                range_y=[-1, 1]\n            )\n            fig.add_hline(y=0, line_dash=\"dash\", line_color=\"gray\")\n            st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No mood data available\")\n\ndef show_patient_alerts(patient_id: int):\n    \"\"\"Show patient alerts for caregiver\"\"\"\n    st.subheader(\"Patient Alerts\")\n    \n    alerts = CaregiverAlertCRUD.get_unresolved_alerts(patient_id)\n    \n    if not alerts:\n        st.success(\"No active alerts!\")\n        return\n    \n    # Filter options\n    severity_filter = st.multiselect(\n        \"Filter by severity:\",\n        [\"low\", \"medium\", \"high\"],\n        default=[\"medium\", \"high\"]\n    )\n    \n    filtered_alerts = [a for a in alerts if a.severity in severity_filter]\n    \n    for alert in filtered_alerts:\n        severity_color = {\n            \"high\": \"üî¥\",\n            \"medium\": \"üü°\",\n            \"low\": \"üü¢\"\n        }.get(alert.severity, \"‚ö™\")\n        \n        with st.expander(f\"{severity_color} {alert.title} - {alert.created_at.strftime('%m/%d %I:%M %p')}\"):\n            st.write(f\"**Type:** {alert.alert_type}\")\n            st.write(f\"**Severity:** {alert.severity}\")\n            st.write(f\"**Description:**\")\n            st.write(alert.description)\n            \n            if st.button(\"Mark as Resolved\", key=f\"resolve_{alert.id}\"):\n                CaregiverAlertCRUD.resolve_alert(alert.id)\n                st.success(\"Alert resolved!\")\n                st.rerun()\n\ndef show_patient_medications(patient_id: int):\n    \"\"\"Show patient medications for caregiver\"\"\"\n    st.subheader(\"Medication Schedule & History\")\n    \n    from app.database.crud import MedicationCRUD\n    import json\n    \n    medications = MedicationCRUD.get_user_medications(patient_id)\n    \n    if not medications:\n        st.info(\"No medications on file\")\n        return\n    \n    for med in medications:\n        with st.expander(f\"{med.name} - {med.dosage}\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.write(f\"**Frequency:** {med.frequency}\")\n                if med.schedule_times:\n                    times = json.loads(med.schedule_times)\n                    st.write(f\"**Schedule:** {', '.join(times)}\")\n                if med.instructions:\n                    st.write(f\"**Instructions:** {med.instructions}\")\n            \n            with col2:\n                adherence = MedicationLogCRUD.get_medication_adherence(patient_id, days=7)\n                med_logs = [log for log in adherence.get(\"logs\", []) if log.medication_id == med.id]\n                \n                if med_logs:\n                    st.write(\"**Recent Activity (Last 7 days):**\")\n                    for log in med_logs[-5:]:\n                        status_emoji = \"‚úÖ\" if log.status == \"taken\" else \"‚ùå\"\n                        st.write(f\"{status_emoji} {log.scheduled_time.strftime('%m/%d %I:%M %p')}\")\n\ndef show_patient_conversations(patient_id: int):\n    \"\"\"Show patient conversations for caregiver\"\"\"\n    st.subheader(\"Recent Conversations\")\n    \n    conversations = ConversationCRUD.get_user_conversations(patient_id, limit=20)\n    \n    if not conversations:\n        st.info(\"No conversations yet\")\n        return\n    \n    for conv in conversations:\n        sentiment_emoji = get_sentiment_emoji(conv.sentiment_score or 0)\n        sentiment_color = get_sentiment_color(conv.sentiment_score or 0)\n        \n        with st.expander(f\"{sentiment_emoji} {conv.timestamp.strftime('%m/%d %I:%M %p')} - {conv.conversation_type}\"):\n            st.write(f\"**Patient:** {conv.message}\")\n            st.write(f\"**Carely:** {conv.response}\")\n            \n            if conv.sentiment_score is not None:\n                st.caption(f\"Mood: {conv.sentiment_label} (score: {conv.sentiment_score:.2f})\")\n","size_bytes":9674},"app/auth/auth_utils.py":{"content":"import hashlib\nimport secrets\nfrom typing import Optional\nfrom app.database.models import User, get_session\nfrom sqlmodel import select\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using SHA-256\"\"\"\n    return hashlib.sha256(password.encode()).hexdigest()\n\ndef verify_password(password: str, password_hash: str) -> bool:\n    \"\"\"Verify a password against its hash\"\"\"\n    return hash_password(password) == password_hash\n\ndef authenticate_user(email: str, password: str) -> Optional[User]:\n    \"\"\"Authenticate a user by email and password\"\"\"\n    with get_session() as session:\n        query = select(User).where(User.email == email)\n        user = session.exec(query).first()\n        \n        if user and user.password_hash and verify_password(password, user.password_hash):\n            return user\n        return None\n\ndef generate_session_token() -> str:\n    \"\"\"Generate a random session token\"\"\"\n    return secrets.token_urlsafe(32)\n\ndef check_permission(user: User, required_role: str) -> bool:\n    \"\"\"Check if user has required permission\"\"\"\n    role_hierarchy = {\n        \"patient\": 0,\n        \"caregiver\": 1,\n        \"admin\": 2\n    }\n    \n    user_level = role_hierarchy.get(user.user_type, 0)\n    required_level = role_hierarchy.get(required_role, 0)\n    \n    return user_level >= required_level\n","size_bytes":1320},"utils/telegram_notification.py":{"content":"import os\nimport requests\nfrom typing import Dict, Any, Optional\n\nclass TelegramNotifier:\n    def __init__(self):\n        self.bot_token = os.getenv(\"TELEGRAM_BOT_TOKEN\")\n        self.base_url = f\"https://api.telegram.org/bot{self.bot_token}\"\n        \n    def send_message(self, chat_id: str, message: str, parse_mode: str = \"HTML\") -> Dict[str, Any]:\n        \"\"\"\n        Send a message to a Telegram chat\n        \n        Args:\n            chat_id: Telegram chat ID\n            message: Message text to send\n            parse_mode: Message format (HTML or Markdown)\n            \n        Returns:\n            Response from Telegram API\n        \"\"\"\n        if not self.bot_token:\n            return {\"success\": False, \"error\": \"Telegram bot token not configured\"}\n            \n        if not chat_id:\n            return {\"success\": False, \"error\": \"Chat ID not provided\"}\n            \n        try:\n            url = f\"{self.base_url}/sendMessage\"\n            payload = {\n                'chat_id': chat_id,\n                'text': message,\n                'parse_mode': parse_mode\n            }\n            \n            response = requests.post(url, json=payload)\n            result = response.json()\n            \n            if result.get(\"ok\"):\n                return {\"success\": True, \"message_id\": result.get(\"result\", {}).get(\"message_id\")}\n            else:\n                return {\"success\": False, \"error\": result.get(\"description\", \"Unknown error\")}\n                \n        except Exception as e:\n            return {\"success\": False, \"error\": str(e)}\n    \n    def send_emergency_alert(\n        self, \n        chat_id: str, \n        patient_name: str, \n        concerns: list, \n        severity: str,\n        message: str\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Send an emergency alert to a caregiver\n        \n        Args:\n            chat_id: Caregiver's Telegram chat ID\n            patient_name: Name of the patient\n            concerns: List of health concerns detected\n            severity: Severity level (low, medium, high)\n            message: Original message from patient\n            \n        Returns:\n            Response from Telegram API\n        \"\"\"\n        severity_emoji = {\n            \"high\": \"üö®\",\n            \"medium\": \"‚ö†Ô∏è\",\n            \"low\": \"‚ÑπÔ∏è\"\n        }\n        \n        emoji = severity_emoji.get(severity, \"‚ÑπÔ∏è\")\n        concerns_text = \"\\n\".join([f\"‚Ä¢ {c}\" for c in concerns])\n        \n        alert_message = f\"\"\"\n{emoji} <b>EMERGENCY ALERT - {severity.upper()} PRIORITY</b> {emoji}\n\n<b>Patient:</b> {patient_name}\n\n<b>Health Concerns Detected:</b>\n{concerns_text}\n\n<b>Original Message:</b>\n\"{message}\"\n\n<b>Time:</b> {self._get_current_time()}\n\n‚ö° Please check on the patient immediately!\n\"\"\"\n        \n        return self.send_message(chat_id, alert_message, parse_mode=\"HTML\")\n    \n    def _get_current_time(self) -> str:\n        \"\"\"Get current time in readable format\"\"\"\n        from datetime import datetime\n        return datetime.now().strftime(\"%I:%M %p, %B %d, %Y\")\n\ndef send_emergency_alert(\n    chat_id: str,\n    patient_name: str,\n    concerns: list,\n    severity: str,\n    message: str\n) -> Dict[str, Any]:\n    \"\"\"Helper function to send emergency alert\"\"\"\n    notifier = TelegramNotifier()\n    return notifier.send_emergency_alert(chat_id, patient_name, concerns, severity, message)\n\ndef send_telegram_message(chat_id: str, message: str) -> Dict[str, Any]:\n    \"\"\"Helper function to send a simple Telegram message\"\"\"\n    notifier = TelegramNotifier()\n    return notifier.send_message(chat_id, message)\n","size_bytes":3572},"utils/emergency_detection.py":{"content":"import os\nfrom openai import OpenAI\nfrom typing import Dict, Any\nimport json\n\nclass EmergencyDetector:\n    def __init__(self):\n        self.client = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n        self.model = \"gpt-4o-mini\"\n        \n    def detect_emergency(self, text: str) -> Dict[str, Any]:\n        \"\"\"\n        Detect if a message contains emergency health concerns\n        Returns: {\n            \"is_emergency\": bool,\n            \"severity\": str (\"low\", \"medium\", \"high\"),\n            \"concerns\": list of detected health concerns,\n            \"confidence\": float (0 to 1)\n        }\n        \"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert health emergency detector for elderly care. \n                        Analyze the given text to determine if it contains emergency health concerns that require immediate attention.\n                        \n                        Look for these emergency indicators:\n                        - Chest pain, pressure, or tightness\n                        - Difficulty breathing, shortness of breath\n                        - Severe dizziness, lightheadedness, or fainting\n                        - Heart palpitations, irregular heartbeat, fast heartbeat\n                        - Severe headache or confusion\n                        - Weakness, numbness (especially on one side)\n                        - Vision problems or speech difficulties\n                        - Severe bleeding or injury\n                        - Allergic reactions\n                        - Severe abdominal pain\n                        \n                        Respond with JSON in this exact format:\n                        {\n                            \"is_emergency\": true/false,\n                            \"severity\": \"low/medium/high\",\n                            \"concerns\": [\"list of specific health concerns detected\"],\n                            \"confidence\": 0.85\n                        }\n                        \n                        - severity \"high\": immediate life-threatening symptoms (chest pain, difficulty breathing, stroke signs)\n                        - severity \"medium\": concerning symptoms that need prompt attention (severe dizziness, fast heartbeat)\n                        - severity \"low\": mild symptoms mentioned casually\n                        \"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": f\"Analyze this message for emergency health concerns: \\\"{text}\\\"\"\n                    }\n                ],\n                response_format={\"type\": \"json_object\"},\n                max_completion_tokens=200\n            )\n            \n            content = response.choices[0].message.content or \"{}\"\n            result = json.loads(content)\n            \n            return {\n                \"is_emergency\": result.get(\"is_emergency\", False),\n                \"severity\": result.get(\"severity\", \"low\"),\n                \"concerns\": result.get(\"concerns\", []),\n                \"confidence\": max(0, min(1, float(result.get(\"confidence\", 0))))\n            }\n            \n        except Exception as e:\n            print(f\"Error in emergency detection: {e}\")\n            return {\n                \"is_emergency\": False,\n                \"severity\": \"low\",\n                \"concerns\": [],\n                \"confidence\": 0\n            }\n\ndef detect_emergency(text: str) -> Dict[str, Any]:\n    \"\"\"Helper function to detect emergency in text\"\"\"\n    detector = EmergencyDetector()\n    return detector.detect_emergency(text)\n","size_bytes":3742}},"version":2}